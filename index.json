[
{
	"uri": "/developers/creating-ti-method/create_ti_method_barebones/",
	"title": "Bare-bones",
	"tags": [],
	"description": "",
	"content": " library(dynwrap) This vignette describes how to include your own method into the dynverse workflow. We’ll illustrate this with a very basic method: using one of the components of a PCA as the pseudotime.\nA method defined in R has two parts: a definition and a function.\nDefinition The definition contains information on the method, its parameters and its required or optional inputs. The possibilities are quite extensive (see dynwrap::definition()), but essentials are:\n Method definition with the id of the method Parameters if applicable. These are defined using the dynparam package. Required inputs (input_required) and if applicable some optional inputs (input_optional). Inputs can be:  expression or counts Some prior information, see dynwrap::priors   definition \u0026lt;- definition( method = def_method( id = \u0026quot;comp1\u0026quot; ), parameters = def_parameters( dynparam::integer_parameter( id = \u0026quot;component\u0026quot;, default = 1, distribution = dynparam::uniform_distribution(1, 10), description = \u0026quot;The nth component to use\u0026quot; ) ), wrapper = def_wrapper( input_required = \u0026quot;expression\u0026quot;, input_optional = \u0026quot;start_id\u0026quot; ) )  Run function The actual inference of the trajectory is done in the run function. This function accepts:\n expression or counts priors A list containing the requested priors parameters A list containing the parameters seed The seed provided by the user. In R this seed is already automatically set verbose Integer of the level of verbosity that will be shown to the user. Based on this message, you can print out different info/warning/error messages.  run_fun \u0026lt;- function(expression, priors, parameters, seed, verbose) { pca \u0026lt;- prcomp(expression) pseudotime \u0026lt;- pca$x[, parameters$component] # flip pseudotimes using start_id if (!is.null(priors$start_id)) { if(mean(pseudotime[start_id]) \u0026gt; 0.5) { pseudotime \u0026lt;- 1-pseudotime } } dynwrap::wrap_data(cell_ids = rownames(expression)) %\u0026gt;% dynwrap::add_linear_trajectory(pseudotime = pseudotime) }  Testing it out To create the method, call create_ti_method_r. At this stage you can also define some R packages that have to be installed or loaded.\nti_comp1 \u0026lt;- create_ti_method_r(definition, run_fun, package_loaded = \u0026quot;dplyr\u0026quot;) This function will return another function that can be used to change any parameters when running the method. This function is also useful to document any parameters when included in an R package.\nThat’s it, let’s try it out:\ndataset \u0026lt;- dynwrap::example_dataset trajectory \u0026lt;- infer_trajectory(dataset, ti_comp1()) if (\u0026quot;dynplot\u0026quot; %in% rownames(installed.packages())) { dynplot::plot_dimred(trajectory, color_cells = \u0026quot;pseudotime\u0026quot; , expression_source = as.matrix(dataset$expression)) }  Making your method available for other users The easiest way to make this method available to others is to put it in anR package which exports the ti_* function. Here you can also provide documentation using roxygen2. The parameters can be automatically documented from the information provided in the description using @eval dynwrap::generate_parameter_documentation(definition) (adapt the name of definition if necessary).\n#\u0026#39; Infer a trajectory from the first principal component #\u0026#39; #\u0026#39; @eval dynwrap::generate_parameter_documentation(definition) #\u0026#39; #\u0026#39; @import dplyr #\u0026#39; @export #\u0026#39; #\u0026#39; @examples #\u0026#39; dataset \u0026lt;- dynwrap::example_dataset #\u0026#39; model \u0026lt;- dynwrap::infer_trajectory(dataset, ti_comp1()¸) ti_comp1 \u0026lt;- create_ti_method_r(definition, run_fun) The parameter documentation will look like follows:\ngenerate_parameter_documentation(definition) ## [1] \u0026quot;@param component The nth component to use. Domain: U(1, 10). Default: 1. Format: integer.\u0026quot; We also strongly encourage you to include within our collection of TI methods available in the dynmethods R package. Feel free to create an issue or send us a pull request.\n "
},
{
	"uri": "/reference/dynwrap/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " dynwrap .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; }    Creating a trajectory   Adapting a trajectory model   Calculations from a trajectory   Creating a TI method   Running a TI method   Other    dynwrap 1.0.0 (unreleased)  MAJOR CHANGE: Add support for Singularity 3.0, drop support for previous releases of Singularity and singularity-hub.\n FEATURE: Add create_ti_method_definition() to create a definition from a local script.\n DOCUMENTATION: Major update of all documentation for release of dynwrap 1.0.0\n MINOR CHANGE: Rename compute_tented_geodesic_distances() to calculate_geodesic_distances()\n MINOR CHANGE: Harmonisation of function arguments to either dataset or trajectory\n   dynwrap 0.3.1.2 (01-02-2019)  BUG FIX: simplify_replace_edges() would sometimes swap edges in milestone network around, but forget invert percentages.\n BUG FIX: Close sinks when interupting the R process\n MINOR CHANGE: Work with new babelwhale, which includes support for singularity 3.0\n        Creating a trajectory Methods to create a trajectory\n    add_branch_trajectory  Create a trajectory given its branch network and the pseudotime of the cells on one of the branches\n   add_cell_graph  Constructs a trajectory using a graph between cells, by mapping cells onto a set of backbone cells.\n   add_cluster_graph  Constructs a trajectory using a cell grouping and a network between groups. Will use an existing grouping if it is present in the dataset.\n   add_cyclic_trajectory  Constructs a circular trajectory using the pseudotime values of each cell.\n   add_dimred_projection  Constructs a trajectory by projecting cells within a dimensionality reduction onto a backbone formed by a milestone network. Optionally, a cell grouping can be given which will restrict the edges on which a cell can be projected.\n   add_end_state_probabilities  Multifurcating trajectory with end state probabilities\n   add_linear_trajectory  Constructs a linear trajectory using the pseudotime values of each cell.\n   add_trajectory is_wrapper_with_trajectory  Define a trajectory dataset given its milestone network and milestone percentages or progressions\n   wrap_data is_data_wrapper  A data wrapper for datasets and trajectories\n    Adapting a trajectory model Methods to adapt a trajectory\n    add_cell_waypoints is_wrapper_with_waypoint_cells  Add cell waypoints to a wrapped trajectory\n   add_dimred is_wrapper_with_dimred get_dimred  Add or create a dimensionality reduction\n   add_expression is_wrapper_with_expression get_expression  Add count and normalised expression values to a dataset\n   add_grouping is_wrapper_with_grouping get_grouping  Add a cell grouping to a dataset\n   add_root add_root_using_expression is_rooted  Root the trajectory\n   add_tde_overall  Add information on overall differentially expressed features\n   add_timings is_wrapper_with_timings add_timing_checkpoint  Add timings checkpoints\n   add_waypoints is_wrapper_with_waypoints select_waypoints  Add or create waypoints to a trajectory\n   gather_cells_at_milestones  \"Gather\" cells to their closest milestones\n   label_milestones label_milestones_markers is_wrapper_with_milestone_labelling get_milestone_labelling  Label milestones either manually (label_milestones) or using marker genes (label_milestones_markers)\n   simplify_trajectory  Simplify a trajectory by removing transient milestones\n    Calculations from a trajectory Deriving features from a trajectory model\n    calculate_pseudotime add_pseudotime  Add or calculate pseudotime as distance from the root\n   calculate_average_by_group  Calculate mean values per cell group\n   calculate_average_by_milestone_percentages  Calculate mean values by milestone percentages\n   calculate_geodesic_distances compute_tented_geodesic_distances  Calculate geodesic distances between cells in a trajectory\n   calculate_trajectory_dimred  Layout the trajectory and its cells in 2 dimensions\n   group_from_trajectory group_onto_trajectory_edges group_onto_nearest_milestones  Create a grouping from a trajectory\n    Creating a TI method Methods to create a TI method wrapper\n    allowed_inputs  All allowed inputs\n   convert_definition  Convert a definition loaded in from a yaml\n   create_ti_method_container  Create a TI method from a docker / singularity container\n   create_ti_method_definition  Create a TI method from a local method definition file\n   create_ti_method_r  Create a TI method wrapper\n   def_author  Meta information on an author\n   def_container  Meta information on the container in which the wrapper resides\n   def_manuscript  Meta information on the manuscript\n   def_method  Define meta information on the TI method.\n   def_parameters  Meta information on the parameters of the TI method\n   def_wrapper  Meta information on the wrapper\n   definition is_ti_method  Create a definition\n   .method_process_definition  Method process definition\n   get_default_parameters  Get the default parameters of a method\n   prior_usages  Metadata on prior usages\n   priors  Metadata on priors\n   trajectory_type_dag  A DAG of trajectory types\n   trajectory_types  Metadata on the trajectory types\n   wrapper_types  Metadata on wrapper types\n    Running a TI method Methods to run one or more TI methods\n    add_prior_information is_wrapper_with_prior_information generate_prior_information  Add prior information to a data wrapper\n   get_ti_methods  Return all TI ti_methods\n   infer_trajectories infer_trajectory  Infer trajectories\n   wrap_expression  Create a wrapper object with expression and counts\n    Other     allowed_outputs  All allowed outputs\n   classify_milestone_network  Classify a milestone network\n   convert_milestone_percentages_to_progressions  Convert milestone percentages to progressions\n   convert_progressions_to_milestone_percentages  Convert progressions to milestone percentages\n   determine_cell_trajectory_positions  Determine the positions of all cells in the trajectory\n   dynwrap dynwrap-package  This R package contains the code for a common model of single-cell trajectories.\n   example_dataset  Example dataset\n   generate_parameter_documentation  Generate the parameter documentation of a method, use with @eval\n   get_divergence_triangles  Helper function for processing divergence regions\n   random_seed  Generate a random seed\n   select_waypoint_cells  Select the waypoint cells\n   simplify_igraph_network  Simplify an igraph network such that consecutive linear edges are removed\n   wrap_output_list  Transform a list of data objects to a dynwrap trajectory\n    Contents Creating a trajectory Adapting a trajectory model Calculations from a trajectory Creating a TI method Running a TI method Other  --  "
},
{
	"uri": "/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "\n\n\n\n"
},
{
	"uri": "/users/1-installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "  Dyno Docker Singularity Frequent installation problems API rate limit exceeded I’m not allowed to install docker on my shared cluster    Dyno dyno contains and loads several of the dynverse R packages (dynwrap, dynplot, dynmethods, …). To install (and update) them all:\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;dynverse/dyno\u0026quot;) On Linux, you will need to install udunits and ImageMagick:\n Debian / Ubuntu / Linux Mint: sudo apt-get install libudunits2-dev imagemagick Fedora / CentOS / RHEL: sudo dnf install udunits2-devel ImageMagick-c++-devel  Docker or Singularity (version ≥ 3.0) has to be installed to run TI methods. We suggest docker on Windows and MacOS, while both docker and singularity are fine when running on linux. Singularity is strongly recommended when running the method on shared computing clusters.\n  Docker For windows 10 you can install Docker CE, older Windows installations require the Docker toolbox.\nYou can test whether docker is correctly installed by running:\ndynwrap::test_docker_installation(detailed = TRUE) ## ✔ Docker is installed ## ✔ Docker daemon is running ## ✔ Docker is at correct version (\u0026gt;1.0): 1.39 ## ✔ Docker is in linux mode ## ✔ Docker can pull images ## ✔ Docker can run image ## ✔ Docker can mount temporary volumes ## ✔ Docker test successful ----------------------------------------------------------------- ## [1] TRUE This command will give helpful tips if some parts of the installation are missing.\n Singularity Installation instructions can be found here: https://www.sylabs.io/docs/. Make sure that version ≥ 3 is installed.\nYou can test whether singularity is correctly installed by running:\ndynwrap::test_singularity_installation(detailed = TRUE) ## ✔ Singularity is installed ## ✔ Singularity is at correct version (\u0026gt;=3.0): v3.0.0-13-g0273e90f is installed ## ✔ Singularity can pull and run a container from Dockerhub ## ✔ Singularity can mount temporary volumes ## ✔ Singularity test successful ------------------------------------------------------------ ## [1] TRUE This command will give helpful tips if some parts of the installation are missing.\n Frequent installation problems API rate limit exceeded Dyno uses several R packages from Github and to do this it uses the GitHub API. By default, this API is limited to 60 requests. This can be easily increased by following the two steps that are recommended by devtools::install_github, namely:\n Use usethis::browse_github_pat() to create a GitHub token Use usethis::edit_r_environ() and add the environment variable with GITHUB_PAT = 'your_github_token. Restart R (so that the GITHUB_PAT is read) and try to reinstall: devtools::install_github(\u0026quot;dynverse/dyno\u0026quot;)   I’m not allowed to install docker on my shared cluster Short answer: use singularity\nDocker indeed poses a security risk when ran in a shared environment. Singularity does not have these risks. For local testing, docker is fine.\n  "
},
{
	"uri": "/users/",
	"title": "Method users",
	"tags": [],
	"description": "",
	"content": " Method users Dyno contains a set of package to infer, visualise and interpret single-cell trajectories.\n Installation for installation instructions. Quick start for getting start with using dyno. User guide guides you through the different parts of dyno Example analyses contains examples of running methods on real datasets See the reference to get help for specific R functions  Need help? Post an issue on Github ➠ https://github.com/dynverse/dyno/issues\n "
},
{
	"uri": "/users/3-user-guide/1-preparing/",
	"title": "Preparing the data",
	"tags": [],
	"description": "",
	"content": "  Gene expression data Prior information Optional information Grouping / clustering Dimensionality reduction  Current limitations   library(dyno) library(tidyverse) The main functions to wrap a dataset are included within the dynwrap package.\nGene expression data As input, dynwrap requires raw counts and normalised (log2) expression data. Cells with low expression, doublets and other “bad” cells should already be filtered from this matrix. Features (i.e. genes) may already be filtered, but this is not required. Some methods internally include a feature filtering step, while others can handle a lot of features just fine.\nInternally, dynwrap works with a sparse matrix (dgCMatrix) which reduces the memory footprint.\ndataset \u0026lt;- wrap_expression( expression = example_dataset$expression, counts = example_dataset$counts )  Prior information Some methods require prior information to be specified. You can add this prior information to the dataset using dynwrap::add_prior_information:\ndataset \u0026lt;- add_prior_information( dataset, start_id = \u0026quot;Cell1\u0026quot; )  Optional information Grouping / clustering You can add a grouping or clustering to the data using dynwrap::add_grouping:\n# dataset \u0026lt;- add_grouping( # dataset, # example_dataset$grouping # )  Dimensionality reduction You can add a grouping or clustering to the data using dynwrap::add_dimred. The dimensionality reduction should be a matrix with the same rownames as the original expression matrix.\ndataset \u0026lt;- add_dimred( dataset, example_dataset$dimred )   Current limitations Currently, alternative input data such as ATAC-Seq or cytometry data are not yet supported, although it is possible to simply include this data as expression and counts.\nIn the near future, we will also add the ability to include RNA velocity as input. See the discussion at https://github.com/dynverse/dynwrap/issues/112.\n "
},
{
	"uri": "/reference/dyneval/evaluation/",
	"title": "dyneval :: Evaluating methods",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Methods to compare different TI methods\n   evaluate_ti_method  Running an evaluation of a method on a set of datasets with a set of parameters\n     "
},
{
	"uri": "/reference/dynplot/plot_trajectory/",
	"title": "dynplot :: Plot a trajectory",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Plotting a trajectory model\n   plot_dendro  Plot a trajectory as a dendrogram\n   plot_dimred  Plot a trajectory on dimensionality reduction\n   plot_graph plot_default  Plot a trajectory and cellular positions as a graph\n   plot_heatmap  Plot the expression across a trajectory in a heatmap\n   plot_onedim  Plot onedim\n   plot_topology  Plot the topology of a trajectory\n     "
},
{
	"uri": "/reference/dynwrap/create_trajectory/",
	"title": "dynwrap :: Creating a trajectory",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Methods to create a trajectory\n   add_branch_trajectory  Create a trajectory given its branch network and the pseudotime of the cells on one of the branches\n   add_cell_graph  Constructs a trajectory using a graph between cells, by mapping cells onto a set of backbone cells.\n   add_cluster_graph  Constructs a trajectory using a cell grouping and a network between groups. Will use an existing grouping if it is present in the dataset.\n   add_cyclic_trajectory  Constructs a circular trajectory using the pseudotime values of each cell.\n   add_dimred_projection  Constructs a trajectory by projecting cells within a dimensionality reduction onto a backbone formed by a milestone network. Optionally, a cell grouping can be given which will restrict the edges on which a cell can be projected.\n   add_end_state_probabilities  Multifurcating trajectory with end state probabilities\n   add_linear_trajectory  Constructs a linear trajectory using the pseudotime values of each cell.\n   add_trajectory is_wrapper_with_trajectory  Define a trajectory dataset given its milestone network and milestone percentages or progressions\n   wrap_data is_data_wrapper  A data wrapper for datasets and trajectories\n     "
},
{
	"uri": "/developers/creating-ti-method/create_ti_method_script/",
	"title": "Wrapper script",
	"tags": [],
	"description": "",
	"content": " library(dynwrap) Still to be written\n"
},
{
	"uri": "/reference/dynplot/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " dynplot .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; }    Plot a trajectory   Visually comparing trajectories   Plotting helper functions   Other    dynplot 1.0.0 (unreleased)  Initial release of dynplot Plotting of trajectories \u0026amp; visual comparisons between trajectories        Plot a trajectory Plotting a trajectory model\n    plot_dendro  Plot a trajectory as a dendrogram\n   plot_dimred  Plot a trajectory on dimensionality reduction\n   plot_graph plot_default  Plot a trajectory and cellular positions as a graph\n   plot_heatmap  Plot the expression across a trajectory in a heatmap\n   plot_onedim  Plot onedim\n   plot_topology  Plot the topology of a trajectory\n    Visually comparing trajectories Plots that help you compare two or more trajectories\n    plot_edge_flips  Plotting edge flips\n   plot_linearised_comparison  Plot strip onedim\n   plot_strip  Plot strip\n    Plotting helper functions Plotting helper functions\n    empty_plot  Create an empty plot for spacing\n   milestone_palette get_milestone_palette_names  Get the names of valid color palettes\n   process_dynplot  Default theme for TI plots\n   theme_clean  We like our plots clean\n   theme_graph  We like our plots clean\n    Other     add_cell_coloring  Add coloring\n   add_density_coloring  Color cells using a background density\n   add_milestone_coloring  Add milestone coloring\n   dynplot dynplot-package  Plot all the trajectories\n   linearise_cells  Linearise a trajectory\n   project_waypoints  Project the waypoints\n    Contents Plot a trajectory Visually comparing trajectories Plotting helper functions Other  --  "
},
{
	"uri": "/developers/creating-ti-method/",
	"title": "Creating a TI method",
	"tags": [],
	"description": "",
	"content": " There are three ways to wrap a TI method:\n Directly through R: Using R packages as dependencies, and using R to read in the data, infer the trajectory and return a trajectory model. This has the least overhead, although you’re restricted to R. Using a wrapper script: A wrapper script in python/R/… that will read the data, infer the trajectory and save the output Using a container: A container in which any dependencies are installed, and which calls a wrapper script internally. This has the largest learning curve, but is the easiest to use on different execution environments and the easiest to distribute to users.  "
},
{
	"uri": "/developers/",
	"title": "Method developers",
	"tags": [],
	"description": "",
	"content": "\n\n\n\n"
},
{
	"uri": "/users/2-quick_start/",
	"title": "Quick start",
	"tags": [],
	"description": "",
	"content": "  Preparing the data Selecting the best methods for a dataset Running the methods Plotting the trajectory Interpreting the trajectory biologically Rooting Milestone labelling  Predicting and visualising genes of interest A global overview of the most predictive genes Lineage/branch markers Genes important at bifurcation points    library(dyno) library(tidyverse) This tutorial quickly guides you through the main steps in the dyno workflow. For each step, we also provide a more in-depth tutorial in the user guide section.\nThe whole trajectory inference workflow is divided in several steps:\nPreparing the data The first step is to prepare the data for trajectory inference using wrap_expression. It requires both the counts and normalised expression (with genes/features in columns) as some TI methods are specifically built for one or the other:\ndata(\u0026quot;fibroblast_reprogramming_treutlein\u0026quot;) dataset \u0026lt;- wrap_expression( counts = fibroblast_reprogramming_treutlein$counts, expression = fibroblast_reprogramming_treutlein$expression ) ➽ An in-depth tutorial for preparing your data\n Selecting the best methods for a dataset When the data is wrapped, the most performant and scalable set of tools can be selected using a shiny app. This app will select a set of methods which are predicted to produce the most optimal output given several user-dependent factors (such as prior expectations about the topology present in the data) and dataset-dependent factors (such as the size of the dataset). This app uses the benchmarking results from dynbenchmark (doi:10.1101/276907).\nguidelines \u0026lt;- guidelines_shiny(dataset) methods_selected \u0026lt;- guidelines$methods_selected ## Loading required namespace: akima ## [1] \u0026quot;slingshot\u0026quot; \u0026quot;paga_tree\u0026quot; \u0026quot;grandprix\u0026quot; \u0026quot;paga\u0026quot; ➽ An in-depth tutorial for selecting the most optimal set of methods\n Running the methods To run a method, it is currently necessary to have either docker or singularity installed. If that’s the case, running a method is a one-step-process. We will run the first selected method here:\nmodel \u0026lt;- infer_trajectory(dataset, first(methods_selected)) ## Loading required namespace: hdf5r Currently, the dynmethod package contains 59 methods!\n➽ An in-depth tutorial for running the methods\n Plotting the trajectory Several visualisation methods provide ways to biologically interpret trajectories.\nExamples include combining a dimensionality reduction, a trajectory model and a cell clustering:\nmodel \u0026lt;- model %\u0026gt;% add_dimred(dyndimred::dimred_mds, expression_source = dataset$expression) plot_dimred( model, expression_source = dataset$expression, grouping = fibroblast_reprogramming_treutlein$grouping ) ## Coloring by grouping Similarly, the expression of a gene:\nplot_dimred( model, expression_source = dataset$expression, feature_oi = \u0026quot;Fn1\u0026quot; ) ## Coloring by expression Groups can also be visualised using a background color\nplot_dimred( model, expression_source = dataset$expression, color_cells = \u0026quot;feature\u0026quot;, feature_oi = \u0026quot;Vim\u0026quot;, color_density = \u0026quot;grouping\u0026quot;, grouping = fibroblast_reprogramming_treutlein$grouping, label_milestones = FALSE ) ➽ An in-depth tutorial for visualising the models\n Interpreting the trajectory biologically In most cases, some knowledge is present of the different start, end or intermediary states present in the data, and this can be used to adapt the trajectory so that it is easier to interpret.\nRooting Most methods have no direct way of inferring the directionality of the trajectory. In this case, the trajectory should be “rooted” using some external information, for example by using a set of marker genes.\nmodel \u0026lt;- model %\u0026gt;% add_root_using_expression(c(\u0026quot;Vim\u0026quot;), dataset$expression)  Milestone labelling Milestones can be labelled using marker genes. These labels can then be used for subsequent analyses and for visualisation.\nmodel \u0026lt;- label_milestones_markers( model, markers = list( MEF = c(\u0026quot;Vim\u0026quot;), Myocyte = c(\u0026quot;Myl1\u0026quot;), Neuron = c(\u0026quot;Stmn3\u0026quot;) ), dataset$expression ) ➽ An in-depth tutorial for adapting the trajectory\n  Predicting and visualising genes of interest We integrate several methods to extract candidate marker genes/features from a trajectory.\nA global overview of the most predictive genes At default, the overall most important genes are calculated when plotting a heatmap.\nplot_heatmap( model, expression_source = dataset$expression, grouping = fibroblast_reprogramming_treutlein$grouping, features_oi = 50 ) ## No features of interest provided, selecting the top 50 features automatically ## Using dynfeature for selecting the top 50 features ## Coloring by grouping  Lineage/branch markers We can also extract features specific for a branch, eg. genes which change when a cell differentiates into a Neuron\nbranch_feature_importance \u0026lt;- calculate_branch_feature_importance(model, expression_source=dataset$expression) neuron_features \u0026lt;- branch_feature_importance %\u0026gt;% filter(to == names(model$milestone_labelling)[which(model$milestone_labelling ==\u0026quot;Neuron\u0026quot;)]) %\u0026gt;% top_n(50, importance) %\u0026gt;% pull(feature_id) plot_heatmap( model, expression_source = dataset$expression, features_oi = neuron_features ) ## Coloring by milestone  Genes important at bifurcation points We can also extract features which change at the branching point\nbranching_milestone \u0026lt;- model$milestone_network %\u0026gt;% group_by(from) %\u0026gt;% filter(n() \u0026gt; 1) %\u0026gt;% pull(from) %\u0026gt;% first() branch_feature_importance \u0026lt;- calculate_branching_point_feature_importance(model, expression_source=dataset$expression, milestones_oi = branching_milestone) branching_point_features \u0026lt;- branch_feature_importance %\u0026gt;% top_n(20, importance) %\u0026gt;% pull(feature_id) plot_heatmap( model, expression_source = dataset$expression, features_oi = branching_point_features ) ## Coloring by milestone space \u0026lt;- dyndimred::dimred_mds(dataset$expression) map(branching_point_features[1:12], function(feature_oi) { plot_dimred(model, dimred = space, expression_source = dataset$expression, feature_oi = feature_oi, label_milestones = FALSE) + theme(legend.position = \u0026quot;none\u0026quot;) + ggtitle(feature_oi) }) %\u0026gt;% patchwork::wrap_plots() ➽ An in-depth tutorial for finding trajectory differentially expressed genes\n  "
},
{
	"uri": "/users/3-user-guide/2-guidelines/",
	"title": "Selecting the best methods for a dataset",
	"tags": [],
	"description": "",
	"content": "     library(dyno) library(tidyverse)  Within our evaluation study, we compared 45 methods on four aspects:\n Accuracy: How similar is the inferred trajectory to the “true” (or “expected”) trajectory in the data. We used several metrics for this, comparing the cellular ordering and topology, and compared against both real datasets, for which a gold standard is not always so well defined, and synthetic data, which are not necessarily as biologically relevant as real data. Scalability: How long the method takes to run and how much memory it consumes. This mainly depends on the dimensions of the input data, i.e. the number of cells and features. Stability: How stable the results are when rerunning the method with different seeds or slightly different input data. Usability: The quality of the documentation and tutorials, how easy it is to run the method, whether the method is well tested, … We created a transparent scoresheet to assess each of these aspects in a more or less objective way.  Perhaps not surprisingly, we found a high diversity in method performance, and that not many methods perform well across the board. The performance of a method depended on many factors, mainly the dimensions of the data and the kind of trajectory present in the data. Based on this, we developed an interactive shiny app which you can use to explore the results and select an optimal set of methods for your analysis.\nThis app can be opened using dynguidelines::guidelines_shiny(). It is recommended to give this function your dataset, so that it will precalculate some fields for you:\ndataset \u0026lt;- example_dataset guidelines_shiny(dataset = dataset) The app includes a tutorial, which will guide you through the user interface. Once finished, it is highly recommended to copy over the code that generates the guidelines to your script, so that your analysis remains reproducible, for example:\ndataset \u0026lt;- example_dataset guidelines \u0026lt;- guidelines( dataset, answers = answer_questions( dataset, multiple_disconnected = FALSE, expect_topology = TRUE, expected_topology = \u0026quot;linear\u0026quot; ) ) ## Loading required namespace: akima This guidelines object contains:\n Information on the selected methods: guidelines$methods The names of the selected methods: guidelines$methods_selected The answers given in the app (or their defaults): guidelines$answers   "
},
{
	"uri": "/reference/dyneval/metric/",
	"title": "dyneval :: Metrics for comparing trajectories",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Metrics for comparing two trajectories\n   calculate_edge_flip  Edge flip score\n   calculate_featureimp_cor  Compare feature importances derived by both trajectories\n   calculate_featureimp_enrichment  Compare enrichment in finding back the most important genes\n   calculate_him  netdist scores\n   calculate_mapping calculate_mapping_milestones calculate_mapping_branches  Compares the mapping between milestones or branches\n   calculate_metrics  Calculate the similarity between two trajectory models.\n   calculate_position_predict  Compute metrics related to the prediction of the positions\n   metrics  Metadata on metrics\n     "
},
{
	"uri": "/reference/dynmethods/other/",
	"title": "dynmethods :: Other",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }     dynmethods dynmethods-package  Wrappers for trajectory inference methods\n   methods  Metadata on the different TI methods\n   ti_angle  Angle\n   ti_calista  CALISTA\n   ti_cellrouter  CellRouter\n   ti_celltrails  CellTrails\n   ti_celltree_gibbs  cellTree Gibbs\n   ti_celltree_maptpx  cellTree maptpx\n   ti_celltree_vem  cellTree vem\n   ti_comp1  Component 1\n   ti_dpt  DPT\n   ti_elpicycle  ElPiGraph - Cycle\n   ti_elpigraph  ElPiGraph\n   ti_elpilinear  ElPiGraph - Linear\n   ti_embeddr  Embeddr\n   ti_error  Error\n   ti_fateid  FateID\n   ti_forks  FORKS\n   ti_gng  GNG\n   ti_gpfates  GPfates\n   ti_grandprix  GrandPrix\n   ti_identity  Identity\n   ti_matcher  MATCHER\n   ti_merlot  MERLoT\n   ti_mfa  MFA\n   ti_monocle_ddrtree  Monocle DDRTree\n   ti_monocle_ica  Monocle ICA\n   ti_mpath  Mpath\n   ti_mst  MST\n   ti_ouija  ouija\n   ti_ouijaflow  ouijaflow\n   ti_paga  PAGA\n   ti_paga_tree  PAGA Tree\n   ti_pcreode  pCreode\n   ti_periodpc  Periodic PrinCurve\n   ti_phenopath  PhenoPath\n   ti_projected_dpt  Projected DPT\n   ti_projected_monocle  Projected Monocle\n   ti_projected_paga  Projected PAGA\n   ti_projected_slingshot  Projected Slingshot\n   ti_projected_tscan  Projected TSCAN\n   ti_pseudogp  pseudogp\n   ti_raceid_stemid  RaceID / StemID\n   ti_random  Random\n   ti_recat  reCAT\n   ti_scimitar  SCIMITAR\n   ti_scorpius  SCORPIUS\n   ti_scoup  SCOUP\n   ti_scuba  SCUBA\n   ti_shuffle  shuffle\n   ti_sincell  Sincell\n   ti_slice  SLICE\n   ti_slicer  SLICER\n   ti_slingshot  Slingshot\n   ti_stemnet  STEMNET\n   ti_topslam  topslam\n   ti_tscan  TSCAN\n   ti_urd  URD\n   ti_wanderlust  Wanderlust\n   ti_waterfall  Waterfall\n   ti_wishbone  Wishbone\n     "
},
{
	"uri": "/reference/dynplot/compare_trajectory/",
	"title": "dynplot :: Visually comparing trajectories",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Plots that help you compare two or more trajectories\n   plot_edge_flips  Plotting edge flips\n   plot_linearised_comparison  Plot strip onedim\n   plot_strip  Plot strip\n     "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/",
	"title": "dynwrap :: Adapting a trajectory model",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Methods to adapt a trajectory\n   add_cell_waypoints is_wrapper_with_waypoint_cells  Add cell waypoints to a wrapped trajectory\n   add_dimred is_wrapper_with_dimred get_dimred  Add or create a dimensionality reduction\n   add_expression is_wrapper_with_expression get_expression  Add count and normalised expression values to a dataset\n   add_grouping is_wrapper_with_grouping get_grouping  Add a cell grouping to a dataset\n   add_root add_root_using_expression is_rooted  Root the trajectory\n   add_tde_overall  Add information on overall differentially expressed features\n   add_timings is_wrapper_with_timings add_timing_checkpoint  Add timings checkpoints\n   add_waypoints is_wrapper_with_waypoints select_waypoints  Add or create waypoints to a trajectory\n   gather_cells_at_milestones  \"Gather\" cells to their closest milestones\n   label_milestones label_milestones_markers is_wrapper_with_milestone_labelling get_milestone_labelling  Label milestones either manually (label_milestones) or using marker genes (label_milestones_markers)\n   simplify_trajectory  Simplify a trajectory by removing transient milestones\n     "
},
{
	"uri": "/reference/dynmethods/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " dynmethods .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; }    Other    dynmethods 0.9.9 (unreleased)  Major changes due to preparation for dynwrap v1.0 release. All methods have been updated, and the format of the dynmethods::methods object has been changed.   dynmethods 0.2.0 (19-11-2018)  SMALL CHANGES: Update for dynwrap 0.3.0 where create_ti_method_with_container() has been renamed to create_ti_method_container().        Other     dynmethods dynmethods-package  Wrappers for trajectory inference methods\n   methods  Metadata on the different TI methods\n   ti_angle  Angle\n   ti_calista  CALISTA\n   ti_cellrouter  CellRouter\n   ti_celltrails  CellTrails\n   ti_celltree_gibbs  cellTree Gibbs\n   ti_celltree_maptpx  cellTree maptpx\n   ti_celltree_vem  cellTree vem\n   ti_comp1  Component 1\n   ti_dpt  DPT\n   ti_elpicycle  ElPiGraph - Cycle\n   ti_elpigraph  ElPiGraph\n   ti_elpilinear  ElPiGraph - Linear\n   ti_embeddr  Embeddr\n   ti_error  Error\n   ti_fateid  FateID\n   ti_forks  FORKS\n   ti_gng  GNG\n   ti_gpfates  GPfates\n   ti_grandprix  GrandPrix\n   ti_identity  Identity\n   ti_matcher  MATCHER\n   ti_merlot  MERLoT\n   ti_mfa  MFA\n   ti_monocle_ddrtree  Monocle DDRTree\n   ti_monocle_ica  Monocle ICA\n   ti_mpath  Mpath\n   ti_mst  MST\n   ti_ouija  ouija\n   ti_ouijaflow  ouijaflow\n   ti_paga  PAGA\n   ti_paga_tree  PAGA Tree\n   ti_pcreode  pCreode\n   ti_periodpc  Periodic PrinCurve\n   ti_phenopath  PhenoPath\n   ti_projected_dpt  Projected DPT\n   ti_projected_monocle  Projected Monocle\n   ti_projected_paga  Projected PAGA\n   ti_projected_slingshot  Projected Slingshot\n   ti_projected_tscan  Projected TSCAN\n   ti_pseudogp  pseudogp\n   ti_raceid_stemid  RaceID / StemID\n   ti_random  Random\n   ti_recat  reCAT\n   ti_scimitar  SCIMITAR\n   ti_scorpius  SCORPIUS\n   ti_scoup  SCOUP\n   ti_scuba  SCUBA\n   ti_shuffle  shuffle\n   ti_sincell  Sincell\n   ti_slice  SLICE\n   ti_slicer  SLICER\n   ti_slingshot  Slingshot\n   ti_stemnet  STEMNET\n   ti_topslam  topslam\n   ti_tscan  TSCAN\n   ti_urd  URD\n   ti_wanderlust  Wanderlust\n   ti_waterfall  Waterfall\n   ti_wishbone  Wishbone\n    Contents Other  --  "
},
{
	"uri": "/developers/evaluating-ti-method/",
	"title": "Evaluating a TI method",
	"tags": [],
	"description": "",
	"content": " library(dynwrap) library(dyneval) library(dynmethods) library(tidyverse) Let’s say we have a dataset with a gold-standard trajectory\ndataset \u0026lt;- dyntoy::generate_dataset(model = \u0026quot;bifurcating\u0026quot;) And run some methods\nmodels \u0026lt;- infer_trajectories(dataset, list(ti_comp1(), ti_mst(), ti_shuffle())) ## Loading required namespace: hdf5r dyneval contains several ways of comparing these two trajectories\nSeveral metrics are sped up by using “waypoint cells”:\ndataset \u0026lt;- add_cell_waypoints(dataset) models$model \u0026lt;- map(models$model, add_cell_waypoints) Now calculate some metrics\nmetric_ids \u0026lt;- dyneval::metrics %\u0026gt;% filter(category != \u0026quot;average\u0026quot;) %\u0026gt;% pull(metric_id) metrics \u0026lt;- map_dfr(models$model, dyneval::calculate_metrics, dataset = dataset, metrics = metric_ids) bind_cols(metrics, models) %\u0026gt;% select(method_id, !!metric_ids) %\u0026gt;% gather(\u0026quot;metric_id\u0026quot;, \u0026quot;metric_value\u0026quot;, -method_id) %\u0026gt;% ggplot(aes(method_id, metric_id, fill = metric_value)) + geom_tile() "
},
{
	"uri": "/users/3-user-guide/3-running/",
	"title": "Inferring trajectories",
	"tags": [],
	"description": "",
	"content": "  Parameters Priors Reproducibility Running multiple methods or datasets Errors Running from the command line   library(dyno) library(tidyverse) dynwrap::infer_trajectory is the main function to infer a trajectory. It requires two things:\n A dataset, wrapped using dynwrap::wrap_expression A TI method. This can be one of the 59 TI method from dynmethods, or a name of a method in which case it will retrieve the relevant method from dynmethods.  dataset \u0026lt;- wrap_expression( counts = example_dataset$counts, expression = example_dataset$expression ) model \u0026lt;- infer_trajectory(dataset, ti_comp1()) ## Loading required namespace: hdf5r This model now contains the main information on the trajectory, i.e. the milestone_network and progressions:\nmodel$milestone_network ## from to length directed ## 1 milestone_begin milestone_end 1 FALSE head(model$progressions, 10) ## cell_id from to percentage ## 1 Cell1 milestone_begin milestone_end 0.25088041 ## 2 Cell2 milestone_begin milestone_end 0.36976202 ## 3 Cell3 milestone_begin milestone_end 0.56873343 ## 4 Cell4 milestone_begin milestone_end 0.91506325 ## 5 Cell5 milestone_begin milestone_end 0.21259337 ## 6 Cell6 milestone_begin milestone_end 0.91000325 ## 7 Cell7 milestone_begin milestone_end 0.90920327 ## 8 Cell8 milestone_begin milestone_end 0.64542720 ## 9 Cell9 milestone_begin milestone_end 0.60957610 ## 10 Cell10 milestone_begin milestone_end 0.06369673 Parameters Optionally, you can also give it some parameters. These are all documented within the relevant functions in dynmethods (also available in the reference section):\n?ti_comp1 ## Component 1 ## ## Description: ## ## Will generate a trajectory using Component 1. ## ## This method was wrapped inside a container. ## ## Usage: ## ## ti_comp1(dimred = \u0026quot;pca\u0026quot;, ndim = 2L, component = 1L) ## ## Arguments: ## ## dimred: Which dimensionality reduction method to use. Domain: pca, ## mds, tsne, ica, lle, landmark_mds, mds_sammon, mds_isomds, ## mds_smacof, umap, dm_diffusionMap. Default: pca. Format: ## character. ## ## ndim: . Domain: U(2, 30). Default: 2. Format: integer. ## ## component: . Domain: U(1, 10). Default: 1. Format: integer. ## ## Value: ## ## A TI method wrapper to be used together with \u0026#39;infer_trajectory\u0026#39; model \u0026lt;- infer_trajectory(dataset, ti_comp1(dimred = \u0026quot;landmark_mds\u0026quot;))  Priors The method will error if it requires some prior information that is not provided in the dataset. Some methods also have optional prior information, in which case you can give them to the method using the give_priors argument:\ndataset \u0026lt;- dataset %\u0026gt;% add_prior_information(start_id = example_dataset$prior_information$start_id) model \u0026lt;- infer_trajectory(dataset, ti_comp1(), give_priors = c(\u0026quot;start_id\u0026quot;))  Reproducibility To make the execution of a method reproducible, fix the seed either using set.seed() or through the seed argument of infer_trajectory:\nset.seed(1) model \u0026lt;- dynwrap::infer_trajectory(dataset, ti_comp1())  Running multiple methods or datasets Often it is useful to run multiple methods and/or use multiple datasets. While you easily parallelise this yourself, we provide a helper function for this: dynwrap::infer_trajectories(). This function integrates well with future interpretation and plotting functions.\nmodels \u0026lt;- dynwrap::infer_trajectories( dataset, method = list(ti_comp1(), ti_angle()) ) This function generates a data frame containing the different models and extra information.\nmodels ## # A tibble: 2 x 7 ## dataset_ix method_ix dataset_id method_id method_name model summary ## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;list\u0026gt; ## 1 1 1 20190326_052… comp1 Component 1 \u0026lt;S3: dy… \u0026lt;tibbl… ## 2 1 2 20190326_052… angle Angle \u0026lt;S3: dy… \u0026lt;tibbl…  Errors Some methods can generate errors which are beyond our control. To know what and where a method generated an error, you can turn on the verbosity:\ndataset$expression@x[] \u0026lt;- NA model \u0026lt;- dynwrap::infer_trajectory(dataset, ti_comp1(), give_priors = c(\u0026quot;start_id\u0026quot;), verbose = TRUE) ## Error: Error during trajectory inference ## Loading required package: dynutils ## Error in svd(x, nu = 0, nv = k) : infinite or missing values in \u0026#39;x\u0026#39; ## Calls: \u0026lt;Anonymous\u0026gt; ... \u0026lt;Anonymous\u0026gt; -\u0026gt; \u0026lt;Anonymous\u0026gt; -\u0026gt; prcomp.default -\u0026gt; svd ## Execution halted ## Executing \u0026#39;comp1\u0026#39; on \u0026#39;20190326_052903__data_wrapper__moLOAxvdLy\u0026#39; ## With parameters: list(dimred = \u0026quot;pca\u0026quot;, ndim = 2L, component = 1L), ## inputs: expression, and ## priors : ## Input saved to /tmp/Rtmphgj0St/file29e72bb1f0c7/ti ## Running /usr/bin/docker run -e \u0026#39;TMPDIR=/tmp2\u0026#39; --workdir /ti/workspace -v \\ ## \u0026#39;/tmp/Rtmphgj0St/file29e72bb1f0c7/ti:/ti\u0026#39; -v \\ ## \u0026#39;/tmp/Rtmphgj0St/file29e74ae430f/tmp:/tmp2\u0026#39; \u0026#39;dynverse/ti_comp1:v0.9.9\u0026#39; \\ ## --dataset /ti/input.h5 --output /ti/output.h5 ## Loading required package: dynutils ## Error in svd(x, nu = 0, nv = k) : infinite or missing values in \u0026#39;x\u0026#39; ## Calls: \u0026lt;Anonymous\u0026gt; ... \u0026lt;Anonymous\u0026gt; -\u0026gt; \u0026lt;Anonymous\u0026gt; -\u0026gt; prcomp.default -\u0026gt; svd ## Execution halted  Running from the command line It is also possible to run each method in dynmethods from the command-line:\ndocker run dynverse/ti_comp1 --help ## Usage: LOCAL=/path/to/folder; MOUNT=/ti; docker run -v $LOCAL:$MOUNT dynverse/ti_comp1 ## ## ## Options: ## -h, --help ## Show this help message and exit ## ## --dataset=DATASET ## Filename of the dataset, example: $MOUNT/dataset.(h5|loom). h5 files can be created by cellranger or dyncli. ## ## --loom_expression_layer=LOOM_EXPRESSION_LAYER ## If available, the name of the loom-layer containing normalised log-transformed data. ## ## --output=OUTPUT ## Filename of the output trajectory data, example: $MOUNT/output.h5. ## ## --parameters=PARAMETERS ## A file containing method-specific parameters, example: $MOUNT/parameters.(h5|yml). ## ## --dimred=DIMRED ## Parameter: Which dimensionality reduction method to use ## Domain: {pca, mds, tsne, ica, lle, landmark_mds, mds_sammon, mds_isomds, mds_smacof, umap, dm_diffusionMap} ## Default: pca ## Format: character ## ## --ndim=NDIM ## Parameter: ## Domain: U(2, 30) ## Default: 2 ## Format: integer ## ## --component=COMPONENT ## Parameter: ## Domain: U(1, 10) ## Default: 1 ## Format: integer ## ## --verbosity=VERBOSITY ## The verbosity level: 0 =\u0026gt; none, 1 =\u0026gt; critical (default), 2 =\u0026gt; info, 3 =\u0026gt; debug. ## ## --seed=SEED ## A seed to be set to ensure reproducability. This container will output an HDF5 file, which can be read by tools such as dynutils::read_h5().\n "
},
{
	"uri": "/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": " Reference   Package Travis Appveyor Codecov Description    dynbenchmark    Scripts to reproduce manuscript  dyno    Complete TI pipeline for end-users  dyndimred    Commonly used dimensionality reduction methods  dyneval    Metrics and evaluation pipeline  dynfeature    Feature selection for trajectories  dyngen    Generator of synthetic datasets  dynguidelines    Interactive guidelines using the results of dynbenchmark  dynmethods    Wrappers for trajectory inference methods  dynnormaliser    Common normalisation functionality  dynplot    Common visualisation functionality  dyntoy    Quick generator of small toy datasets  dynutils    Various common functions  dynwrap    Common trajectory wrapping functionality     "
},
{
	"uri": "/users/3-user-guide/",
	"title": "User guide",
	"tags": [],
	"description": "",
	"content": " Throughout this guide, we frequently make use of some tidyverse functions, mainly coming from dplyr, purrr, tibble and ggplot2. While learning the tidyverse functions of course takes some time, in the long run it will make working in R a lot easier. The best way to learn it for people using R is the R for Data Science book: https://r4ds.had.co.nz/.\n "
},
{
	"uri": "/reference/dyneval/other/",
	"title": "dyneval :: Other",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }     dyneval dyneval-package  Evaluating trajectory inference methods\n     "
},
{
	"uri": "/reference/dynplot/plot_helpers/",
	"title": "dynplot :: Plotting helper functions",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Plotting helper functions\n   empty_plot  Create an empty plot for spacing\n   milestone_palette get_milestone_palette_names  Get the names of valid color palettes\n   process_dynplot  Default theme for TI plots\n   theme_clean  We like our plots clean\n   theme_graph  We like our plots clean\n     "
},
{
	"uri": "/reference/dynwrap/derive_trajectory/",
	"title": "dynwrap :: Calculations from a trajectory",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Deriving features from a trajectory model\n   calculate_pseudotime add_pseudotime  Add or calculate pseudotime as distance from the root\n   calculate_average_by_group  Calculate mean values per cell group\n   calculate_average_by_milestone_percentages  Calculate mean values by milestone percentages\n   calculate_geodesic_distances compute_tented_geodesic_distances  Calculate geodesic distances between cells in a trajectory\n   calculate_trajectory_dimred  Layout the trajectory and its cells in 2 dimensions\n   group_from_trajectory group_onto_trajectory_edges group_onto_nearest_milestones  Create a grouping from a trajectory\n     "
},
{
	"uri": "/developers/creating-ti-method/create_ti_method_container/",
	"title": "Container",
	"tags": [],
	"description": "",
	"content": " library(dynwrap) Still to be written\n"
},
{
	"uri": "/reference/dyneval/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " dyneval .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; }    Evaluating methods   Metrics for comparing trajectories   Other    dyneval 0.2.3 (unreleased)  MINOR CHANGE: update categories of metrics   dyneval 0.2.2 (21-11-2018)  DOCUMENTATION: Update and expand documentation.\n BUG FIX: Update dyneval for dynwrap 0.3.1 (#50).\n MINOR CHANGE: Clean up imports and suggests.\n        Evaluating methods Methods to compare different TI methods\n    evaluate_ti_method  Running an evaluation of a method on a set of datasets with a set of parameters\n    Metrics for comparing trajectories Metrics for comparing two trajectories\n    calculate_edge_flip  Edge flip score\n   calculate_featureimp_cor  Compare feature importances derived by both trajectories\n   calculate_featureimp_enrichment  Compare enrichment in finding back the most important genes\n   calculate_him  netdist scores\n   calculate_mapping calculate_mapping_milestones calculate_mapping_branches  Compares the mapping between milestones or branches\n   calculate_metrics  Calculate the similarity between two trajectory models.\n   calculate_position_predict  Compute metrics related to the prediction of the positions\n   metrics  Metadata on metrics\n    Other     dyneval dyneval-package  Evaluating trajectory inference methods\n    Contents Evaluating methods Metrics for comparing trajectories Other  --  "
},
{
	"uri": "/users/4-example_analyses/",
	"title": "Example analyses",
	"tags": [],
	"description": "",
	"content": "\n\n\n\n"
},
{
	"uri": "/users/3-user-guide/4-visualisation/",
	"title": "Visualising the trajectory",
	"tags": [],
	"description": "",
	"content": "  Visualising the trajectory on a dimensionality reduction Plotting the trajectory itself Plotting in a dendrogram Plotting as a graph Plotting in one dimension  Visualising many genes along a trajectory Current limitations   library(dyno) library(tidyverse) The main functions for plotting a trajectory are included in the dynplot package.\nWe’ll use an example toy dataset\nset.seed(1) dataset \u0026lt;- dyntoy::generate_dataset(model = \u0026quot;bifurcating\u0026quot;, num_cells = 200) To visualise a trajectory, you have to take into acount two things:\n Where will I place the trajectory and cells in my 2D space What do I want to visualise along the trajectory based on color  Depending on the answer on these two questions, you will need different visualisations:\nVisualising the trajectory on a dimensionality reduction The most common way to visualise a trajectory is to plot it on a dimensionality reduction of the cells. Often (but not always), a TI method will already output a dimensionality reduction itself, which was used to construct the trajectory. For example:\nmodel \u0026lt;- infer_trajectory(dataset, ti_mst()) ## Loading required namespace: hdf5r head(get_dimred(model), 5) ## comp_1 comp_2 ## C1 -16.665552 -2.0932842 ## C2 -6.100642 -5.8776537 ## C3 -13.504351 -8.2116550 ## C4 -15.828066 0.9743139 ## C5 7.454530 -11.1981456 Dynplot will use this dimensionality reduction if available, otherwise it will calculate a dimensionality reduction under the hood:\nplot_dimred(model) ## Coloring by milestone ## Using milestone_percentages from traj You can also supply it with your own dimensionality reduction. In this case, the trajectory will be projected onto this dimensionality reduction.\ndimred \u0026lt;- dyndimred::dimred_umap(dataset$expression) ## Loading required namespace: uwot plot_dimred(model, dimred = dimred) ## Coloring by milestone ## Using milestone_percentages from traj On this plot, you can color the cells according to\nCell ordering. In which every milestone gets a color and the color changes gradually between the milestones. This is the default. Cell grouping. A character vector mapping a cell to a group. In this example, we group the cells to their nearest milestone, but typically you will want to supply some external clustering here. Feature expression. In which case you need to supply the expression_source which is usually the original dataset, but can be in any format accepted by dynwrap::get_expression(). Pseudotime. The distance to a particular root milestone. The adapting guide discusses how to change the root of a trajectory.  patchwork::wrap_plots( plot_dimred(model) + ggtitle(\u0026quot;Cell ordering\u0026quot;), plot_dimred(model, grouping = group_onto_nearest_milestones(model)) + ggtitle(\u0026quot;Cell grouping\u0026quot;), plot_dimred(model, feature_oi = \u0026quot;G1\u0026quot;, expression_source = dataset) + ggtitle(\u0026quot;Feature expression\u0026quot;), plot_dimred(model, \u0026quot;pseudotime\u0026quot;, pseudotime = calculate_pseudotime(model)) + ggtitle(\u0026quot;Pseudotime\u0026quot;) ) ## Coloring by milestone ## Using milestone_percentages from traj ## Coloring by grouping ## Coloring by expression ## root cell or milestone not provided, trying first outgoing milestone_id ## Using \u0026#39;M1\u0026#39; as root The result is just a regular ggplot2 object, so you can change and adapt it further:\nplot_dimred(model) + ggtitle(\u0026quot;Cells are amazing\u0026quot;) + annotate(\u0026quot;label\u0026quot;, x = model$dimred[1, 1], y = model$dimred[1, 2], label = \u0026quot;Amazing cells\u0026quot;) + annotate(\u0026quot;label\u0026quot;, x = model$dimred[2, 1], y = model$dimred[2, 2], label = \u0026quot;Also amazing cells\u0026quot;) ## Coloring by milestone ## Using milestone_percentages from traj   Plotting the trajectory itself If the dataset is too complex to be visualised using a 2D dimensionality reduction, it can be useful to visualise the trajectory itself. We provide 3 ways to do this:\nPlotting in a dendrogram When the trajectory has a tree structure and a clear direction, it is often the most intuitive to visualise it as a dendrogram:\nplot_dendro(model) ## root cell or milestone not provided, trying first outgoing milestone_id ## Using \u0026#39;M1\u0026#39; as root ## Coloring by milestone ## Using milestone_percentages from traj This visualisation hinges on the correct location of a root, which will be further discussed in the adapting guide.\nHere you can again color the cells in different ways similar as plot_dimred, i.e.:\nplot_dendro(model, \u0026quot;pseudotime\u0026quot;) ## root cell or milestone not provided, trying first outgoing milestone_id ## Using \u0026#39;M1\u0026#39; as root ## Pseudotime not provided, will calculate pseudotime from root milestone  Plotting as a graph For more complex topologies, which include cycles or disconnected pieces, the trajectory can be visualised as a 2D graph structure.\ndisconnected_dataset \u0026lt;- dyntoy::generate_trajectory(model = \u0026quot;disconnected\u0026quot;, num_cells = 300) plot_graph(disconnected_dataset) ## Coloring by milestone ## Using milestone_percentages from traj  Plotting in one dimension Sometimes it can be useful to visualise the trajectory in one dimension, so that you can use the other dimension for something else:\nplot_onedim(add_root(model)) ## root cell or milestone not provided, trying first outgoing milestone_id ## Using \u0026#39;M1\u0026#39; as root ## Coloring by milestone ## Using milestone_percentages from traj   Visualising many genes along a trajectory Heatmap plotting is currently still experimental.\n A one-dimensional visualisation is especially useful if you combine it with a heatmap:\nplot_heatmap(model, expression_source = dataset) ## No features of interest provided, selecting the top 20 features automatically ## Using dynfeature for selecting the top 20 features ## root cell or milestone not provided, trying first outgoing milestone_id ## Using \u0026#39;M1\u0026#39; as root ## Coloring by milestone Selecting relevant features for this heatmap is discussed in a later guide, but suffice it to say that plot_heatmap() by default will plot those features that best explain the main differences over the whole trajectory.\n Current limitations Plotting of RNA velocity on top of a trajectory would be very very useful, but is not yet included. See the issue on github: https://github.com/dynverse/dynplot/issues/29\n "
},
{
	"uri": "/reference/dynplot/other/",
	"title": "dynplot :: Other",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }     add_cell_coloring  Add coloring\n   add_density_coloring  Color cells using a background density\n   add_milestone_coloring  Add milestone coloring\n   dynplot dynplot-package  Plot all the trajectories\n   linearise_cells  Linearise a trajectory\n   project_waypoints  Project the waypoints\n     "
},
{
	"uri": "/reference/dynwrap/create_ti_method/",
	"title": "dynwrap :: Creating a TI method",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Methods to create a TI method wrapper\n   allowed_inputs  All allowed inputs\n   convert_definition  Convert a definition loaded in from a yaml\n   create_ti_method_container  Create a TI method from a docker / singularity container\n   create_ti_method_definition  Create a TI method from a local method definition file\n   create_ti_method_r  Create a TI method wrapper\n   def_author  Meta information on an author\n   def_container  Meta information on the container in which the wrapper resides\n   def_manuscript  Meta information on the manuscript\n   def_method  Define meta information on the TI method.\n   def_parameters  Meta information on the parameters of the TI method\n   def_wrapper  Meta information on the wrapper\n   definition is_ti_method  Create a definition\n   .method_process_definition  Method process definition\n   get_default_parameters  Get the default parameters of a method\n   prior_usages  Metadata on prior usages\n   priors  Metadata on priors\n   trajectory_type_dag  A DAG of trajectory types\n   trajectory_types  Metadata on the trajectory types\n   wrapper_types  Metadata on wrapper types\n     "
},
{
	"uri": "/users/3-user-guide/5-adapting/",
	"title": "Adapting the trajectory",
	"tags": [],
	"description": "",
	"content": "  Simplifying Rooting Manually Using marker genes  Annotating Manually Using marker genes  Limitations   library(dyno) library(tidyverse) Simplifying Intermediate milestones can be removed by simplyfing the trajectory:\nmodel \u0026lt;- dyntoy::generate_dataset(model = dyntoy::model_linear(num_milestones = 10)) simplified \u0026lt;- simplify_trajectory(model)  Rooting TI methods often do not have an idea where the root of a trajectory is. We provide two ways of rooting a trajectory. After rooting, all other edges will point away from the root.\nset.seed(1) model \u0026lt;- dyntoy::generate_dataset(model = dyntoy::model_bifurcating()) Manually If you know the milestone (or cell) that is at the start of the trajectory, you can directly call add_root:\nmodel_rooted \u0026lt;- model %\u0026gt;% add_root(root_milestone_id = \u0026quot;M4\u0026quot;)  Using marker genes If you know some marker genes that are highly expressed at the start of the trajectory, rooting can be done implicitely:\nmodel_rooted \u0026lt;- model %\u0026gt;% add_root_using_expression(\u0026quot;G1\u0026quot;, expression_source = model) Rooting a trajectory based on RNA velocity is on our todo list. See https://github.com/dynverse/dynwrap/issues/115\n   Annotating Annotating/labelling milestones is still experimental\n Similarly as with rooting, there are also two ways to annotate the milestones within a trajectory:\nManually model_labelled \u0026lt;- model %\u0026gt;% label_milestones(c(M1 = \u0026quot;start\u0026quot;, M2 = \u0026quot;end1\u0026quot;, M3 = \u0026quot;decision\u0026quot;, M4 = \u0026quot;end2\u0026quot;))  Using marker genes model_labelled \u0026lt;- label_milestones_markers( model, markers = list( G1high = c(\u0026quot;G1\u0026quot;), G5high = c(\u0026quot;G5\u0026quot;), G3high = c(\u0026quot;G3\u0026quot;), G8high = c(\u0026quot;G8\u0026quot;) ) ) Annotating milestones based on external information is on our todo list.\n   Limitations Splitting a trajectory and adding intermediate milestones is on our todo list.\n  "
},
{
	"uri": "/reference/dynwrap/infer_trajectory/",
	"title": "dynwrap :: Running a TI method",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }  Methods to run one or more TI methods\n   add_prior_information is_wrapper_with_prior_information generate_prior_information  Add prior information to a data wrapper\n   get_ti_methods  Return all TI ti_methods\n   infer_trajectories infer_trajectory  Infer trajectories\n   wrap_expression  Create a wrapper object with expression and counts\n     "
},
{
	"uri": "/users/3-user-guide/6-tde/",
	"title": "Trajectory differentially expression",
	"tags": [],
	"description": "",
	"content": "  A global overview of the most predictive genes Lineage/branch markers Genes important at bifurcation points Current limitations   library(dyno) library(tidyverse) Compared to differential expression between clusters of cells, defining differential expression on trajectories is not so straightforward. What constitutes a trajectory differentially expressed gene?\n A gene that is uniquely expressed in a particular branch? A gene that changes at a branching point? A gene that changes along pseudotime? …?  dynfeature is a package that allows you to find these different kinds of differential expression in a trajectory. It first defines a particular variable that needs to be predicted (for example, whether a cell is present in a branch or not), and tries to predict this variable based on the expression in different cells. It then ranks each feature based on their predictive capability, and based on this ranking you can select differentially expressed genes.\nDepending on what variable is predicted, you get a different ranking. This simply depends on what kind of features you are interested in:\nA global overview of the most predictive genes If you just want to see features that change anywhere in the trajectory, you can use `dynfeature::\nmodel \u0026lt;- dyntoy::generate_dataset(model = dyntoy::model_bifurcating(), num_features = 500) overall_feature_importances \u0026lt;- dynfeature::calculate_overall_feature_importance(model) features \u0026lt;- overall_feature_importances %\u0026gt;% top_n(40, importance) %\u0026gt;% pull(feature_id)  Lineage/branch markers We can also extract features that are specifically upregulated or downregulated in a specific branch:\nbranch_feature_importance \u0026lt;- calculate_branch_feature_importance(model) features \u0026lt;- branch_feature_importance %\u0026gt;% filter(to == \u0026quot;M4\u0026quot;) %\u0026gt;% top_n(20, importance) %\u0026gt;% pull(feature_id)  Genes important at bifurcation points We can also extract features which change at the branching point\nbranching_milestone \u0026lt;- \u0026quot;M3\u0026quot; branch_feature_importance \u0026lt;- calculate_branching_point_feature_importance(model, milestones_oi = branching_milestone) features \u0026lt;- branch_feature_importance %\u0026gt;% top_n(20, importance) %\u0026gt;% pull(feature_id)  Current limitations While dynfeature is useful to rank the features according to the strength of trajectory differential expression, they do not provide a statistical ground to find features which are significantly differentially expressed.\n "
},
{
	"uri": "/reference/dynwrap/other/",
	"title": "dynwrap :: Other",
	"tags": [],
	"description": "",
	"content": " .ref-index p{ margin: 0 0 0 0; } .ref-index .copy-to-clipboard { opacity: 0.4; } .ref-index h2 { margin: 0.85rem 0 1.7rem 0; }     allowed_outputs  All allowed outputs\n   classify_milestone_network  Classify a milestone network\n   convert_milestone_percentages_to_progressions  Convert milestone percentages to progressions\n   convert_progressions_to_milestone_percentages  Convert progressions to milestone percentages\n   determine_cell_trajectory_positions  Determine the positions of all cells in the trajectory\n   dynwrap dynwrap-package  This R package contains the code for a common model of single-cell trajectories.\n   example_dataset  Example dataset\n   generate_parameter_documentation  Generate the parameter documentation of a method, use with @eval\n   get_divergence_triangles  Helper function for processing divergence regions\n   random_seed  Generate a random seed\n   select_waypoint_cells  Select the waypoint cells\n   simplify_igraph_network  Simplify an igraph network such that consecutive linear edges are removed\n   wrap_output_list  Transform a list of data objects to a dynwrap trajectory\n     "
},
{
	"uri": "/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " dynbenchmark Benchmarking \n dyneval Comparing \n dynplot Visualising \n     \n dynwrap Wrapping \n dynguidelines Guidelines \n dynmethods Inferring \n     .row.logos { margin-top:-25px; } @media only all and (max-width: 47.938em) { .row.logos { margin-top:0px; } } .outer-div { position: relative; float: right; right: 50%; } .inner-div { position: relative; float: right; right: -50%; white-space: nowrap} .hex { display:inline-block; margin: 0px 10px 0px 10px; text-align: center; } .hex img { max-height: 100px; margin: 0px auto !important; } .hex p { margin: 0!important; } .hex a { color: #333333; } .hex span { opacity: 0; transition: 0.3s; } .hex:hover span { opacity: 1; }  dynverse is a collection of R packages aimed at supporting the trajectory inference (TI) community on multiple levels: end-users who want to apply TI on their dataset of interest, and developers who seek to easily quantify the performance of their TI method and compare it to other TI methods.\nSome of these packages were developed as part of a benchmarking study ➙\n  A comparison of single-cell trajectory inference methods  Helena Todorov, Yvan Saeys.  Nature Biotechnology (In press) doi:10.1038/s41587-019-0071-9  bioRxiv (Mar. 2018) doi:10.1101/276907      .__dimensions_badge_embed__{display:inline!important;}    Want to infer and interpret trajectories? The dyno package offers end-users a complete TI pipeline. It features:\n a uniform interface to 50+ TI methods, an interactive guideline tool to help you select the most appropriate method, streamlined interpretation and visualisation of trajectories, and downstream analyses such as the identification of differentially expressed features  Check out the quick started or the user guide.\nNeed help? Post an issue on Github ➙ https://github.com/dynverse/dyno\n Want to create and evaluate a method? For developers of existing or new TI methods, dyno offers the same features as to end-users. In addition, developers might also want to check out the following packages:\n dynmethods, which is a repository of wrappers for TI methods. If your method has already been included in dynmethods, an issue will have been created there. dynwrap, the wrapping functions for transforming common trajectory data formats into the common trajectory model supported by dynverse. dynbenchmark, all source code in order to replicate the benchmarking study by Saelens and Cannoodt (10.1101/276907). Check out this overview of all dynverse packages for more information of the functionality of each package.      .wt:before{ content: ''; animation: wt 10s linear infinite; } @keyframes wt { 0% {opacity:0; content: \"Wouter Saelens*, \"} 5% {opacity:1; } 45% {opacity:1; } 50% {opacity:0; content: \"Wouter Saelens*, \"} 51% {opacity:0; content: \"Robrecht Cannoodt*, \"} 55% {opacity:1; } 95% {opacity:1; } 99% {opacity:0; content: \"Robrecht Cannoodt*, \"} 100% {opacity:0; content: \"Wouter Saelens*, \"} } .rc:before{ content: ''; animation: rc 10s linear infinite; } @keyframes rc { 0% {opacity:0; content: \"Robrecht Cannoodt*, \"} 5% {opacity:1; content: \"Robrecht Cannoodt*, \"} 45% {opacity:1; content: \"Robrecht Cannoodt*, \"} 50% {opacity:0; content: \"Robrecht Cannoodt*, \"} 51% {opacity:0; content: \"Wouter Saelens*, \"} 55% {opacity:1; content: \"Wouter Saelens*, \"} 95% {opacity:1; content: \"Wouter Saelens*, \"} 99% {opacity:0; content: \"Wouter Saelens*, \"} 100% {opacity:0; content: \"Robrecht Cannoodt*, \"} }  "
},
{
	"uri": "/logo-accordion/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " dynbenchmark Benchmarking   dyneval Comparing   dynplot Visualising   \u0026nbsp; \u0026nbsp;   dynwrap Wrapping   dynguidelines Guidelines   dynmethods Inferring       .row.logos { margin-top:-25px; } @media only all and (max-width: 47.938em) { .row.logos { margin-top:0px; } } .outer-div { position: relative; float: right; right: 50%; } .inner-div { position: relative; float: right; right: -50%; white-space: nowrap } .hex { display:inline-block; margin: 0px 10px 0px 10px; text-align: center; } .hex img { max-height: 100px; margin: 0px auto !important; } .hex p { margin: 0!important; } .hex a { color: #333333; } .hex span { opacity: 0; transition: 0.3s ; } .hex:hover span { opacity: 1; }  "
},
{
	"uri": "/page-top/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/gather_cells_at_milestones/",
	"title": "&#34;Gather&#34; cells to their closest milestones",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_gather_cells_at_milestones.R gather_cells_at_milestones.Rd  \"Gather\" cells to their closest milestones\n gather_cells_at_milestones(trajectory) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/trajectory_type_dag/",
	"title": "A DAG of trajectory types",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R trajectory_type_dag.Rd  A DAG of trajectory types\n trajectory_type_dag Format An object of class tbl_graph (inherits from igraph) of length 10.\n Contents Format  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/wrap_data/",
	"title": "A data wrapper for datasets and trajectories",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_data.R wrap_data.Rd  A data wrapper for datasets and trajectories\n wrap_data(id = NULL, cell_ids, cell_info = NULL, ...) is_data_wrapper(dataset) Arguments   id A unique identifier for the data. If NULL, a random string will be generated.\n   cell_ids The ids of the cells.\n   cell_info Optional meta-information pertaining the cells.\n   ... Extra information to be stored in the wrapper.\n   dataset A dataset created by wrap_data() or wrap_expression()\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_grouping/",
	"title": "Add a cell grouping to a dataset",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_grouping.R add_grouping.Rd  Add a cell grouping to a dataset\n add_grouping(dataset, grouping, group_ids = NULL, ...) is_wrapper_with_grouping(dataset) get_grouping(dataset, grouping = NULL) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   grouping A grouping of the cells, can be a named vector or a dataframe with group_id (character) and cell_id (character)\n   group_ids All group_ids, optional\n   ... Extra information to be stored in the dataset\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_cell_waypoints/",
	"title": "Add cell waypoints to a wrapped trajectory",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_cell_waypoints.R add_cell_waypoints.Rd  Add cell waypoints to a wrapped trajectory\n add_cell_waypoints(trajectory, num_cells_selected = 100) is_wrapper_with_waypoint_cells(trajectory) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   num_cells_selected About the number of cells selected as waypoints\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/other/add_cell_coloring/",
	"title": "Add coloring",
	"tags": [],
	"description": "",
	"content": " add_cell_coloring.Rd  Add coloring\n add_cell_coloring(cell_positions, color_cells = c(\"auto\", \"none\", \"grouping\", \"feature\", \"milestone\", \"pseudotime\"), traj, grouping = NULL, groups = NULL, feature_oi = NULL, expression_source = \"expression\", pseudotime = NULL, color_milestones = c(\"auto\", \"given\", \"cubeHelix\", \"Set3\", \"rainbow\"), milestones = NULL, milestone_percentages = NULL) Arguments   cell_positions The positions of the cells\n   color_cells How to color the cells\n   traj The trajectory\n   grouping The grouping of the cells\n   groups Tibble containing information of the cell groups\n   feature_oi feature to plot expression\n   expression_source Source of the feature expression, defaults to `expression`\n   pseudotime The pseudotime\n   color_milestones How to color the cells\n   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   milestone_percentages The milestone percentages\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_expression/",
	"title": "Add count and normalised expression values to a dataset",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_expression.R add_expression.Rd  Add count and normalised expression values to a dataset\n add_expression(dataset, counts, expression, feature_info = NULL, ...) is_wrapper_with_expression(dataset) get_expression(dataset, expression_source = \"expression\") Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   counts The counts with genes in columns and cells in rows\n   expression The normalised expression values with genes in columns and cells in rows\n   feature_info Optional meta-information of the features, a data.frame with at least feature_id as column\n   ... extra information to be stored in the dataset\n   expression_source The source of expression, can be \"counts\", \"expression\", an expression matrix, or another dataset which contains expression\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_tde_overall/",
	"title": "Add information on overall differentially expressed features",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_tde_overall.R add_tde_overall.Rd  Add information on overall differentially expressed features\n add_tde_overall(trajectory, tde_overall) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   tde_overall A tibble containing a feature_id (character) and differentially_expressed (logical). Can also contain other columns, such as the p-value, q-value, log fold-change, etc\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/other/add_milestone_coloring/",
	"title": "Add milestone coloring",
	"tags": [],
	"description": "",
	"content": " add_milestone_coloring.Rd  Add milestone coloring\n add_milestone_coloring(milestones = NULL, color_milestones = c(\"auto\", \"given\", \"cubeHelix\", \"Set3\", \"rainbow\")) Arguments   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   color_milestones How to color the cells\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/derive_trajectory/calculate_pseudotime/",
	"title": "Add or calculate pseudotime as distance from the root",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_pseudotime.R add_pseudotime.Rd  Add or calculate pseudotime as distance from the root\n calculate_pseudotime(trajectory) add_pseudotime(trajectory, pseudotime = NULL) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   pseudotime Named vector containing the pseudotime for every cell\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_dimred/",
	"title": "Add or create a dimensionality reduction",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_dimred.R add_dimred.Rd  Add or create a dimensionality reduction\n add_dimred(dataset, dimred, dimred_milestones = NULL, dimred_segment_progressions = NULL, dimred_segment_points = NULL, connect_segments = FALSE, expression_source = \"expression\", ...) is_wrapper_with_dimred(dataset) get_dimred(dataset, dimred = NULL, expression_source = \"expression\") Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   dimred The dimensionality reduction matrix (with cell_ids as rownames) or function which will run the dimensionality reduction\n   dimred_milestones An optional dimensionality reduction of the milestones.\n   dimred_segment_progressions An optional progression matrix of the trajectory segments. Format: tibble(from, to, percentage)\n   dimred_segment_points An optional dimensionality reduction of the trajectory segments. Format: matrix(Comp1, Comp2, ...).\n   connect_segments Whether to connect segments between edges\n   expression_source The source of expression, can be \"counts\", \"expression\", an expression matrix, or another dataset which contains expression\n   ... extra information to be stored in the wrapper\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_waypoints/",
	"title": "Add or create waypoints to a trajectory",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_waypoints.R add_waypoints.Rd  Add or create waypoints to a trajectory\nWaypoints are spread equally over the whole trajectory\n add_waypoints(trajectory, n_waypoints = 100, resolution = sum(trajectory$milestone_network$length)/n_waypoints) is_wrapper_with_waypoints(trajectory) select_waypoints(trajectory, n_waypoints = 100, resolution = sum(trajectory$milestone_network$length)/n_waypoints) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   n_waypoints The number of waypoints\n   resolution The resolution of the waypoints, measured in the same units as the lengths of the milestone network edges, will be automatically computed using n_waypoints\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/infer_trajectory/add_prior_information/",
	"title": "Add prior information to a data wrapper",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_prior_information.R add_prior_information.Rd  Note that the given data wrapper requires a trajectory and expression values to have been added already.\nFor example, what are the start cells, the end cells, to which milestone does each cell belong to, ...\n add_prior_information(dataset, start_id = NULL, end_id = NULL, groups_id = NULL, groups_network = NULL, features_id = NULL, groups_n = NULL, start_n = NULL, end_n = NULL, timecourse_continuous = NULL, timecourse_discrete = NULL, verbose = TRUE) is_wrapper_with_prior_information(dataset) generate_prior_information(cell_ids, milestone_ids, milestone_network, milestone_percentages, progressions, divergence_regions, expression, feature_info = NULL, cell_info = NULL, marker_fdr = 0.005, given = NULL, verbose = FALSE) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   start_id The start cells\n   end_id The end cells\n   groups_id The grouping of cells, a dataframe with cell_id and group_id\n   groups_network The network between groups, a dataframe with from and to\n   features_id The features (genes) important for the trajectory\n   groups_n Number of branches\n   start_n Number of start states\n   end_n Number of end states\n   timecourse_continuous The time for every cell\n   timecourse_discrete The time for every cell in groups\n   verbose Whether or not to print informative messages\n   cell_ids The ids of the cells.\n   milestone_ids The ids of the milestones in the trajectory. Type: Character vector.\n   milestone_network The network of the milestones. Type: Data frame(from = character, to = character, length = numeric, directed = logical).\n   milestone_percentages A data frame specifying what percentage milestone each cell consists of. Type: Data frame(cell_id = character, milestone_id = character, percentage = numeric).\n   progressions Specifies the progression of a cell along a transition in the milestone_network. Type: Data frame(cell_id = character, from = character, to = character, percentage = numeric).\n   divergence_regions A data frame specifying the divergence regions between milestones (e.g. a bifurcation). Type: Data frame(divergence_id = character, milestone_id = character, is_start = logical).\n   expression The normalised expression values with genes in columns and cells in rows\n   feature_info Optional meta-information of the features, a data.frame with at least feature_id as column\n   cell_info Optional meta-information pertaining the cells.\n   marker_fdr Maximal FDR value for a gene to be considered a marker\n   given Prior information already calculated\n   Details The dataset has to contain a trajectory for this to work\n Contents Arguments Details  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_timings/",
	"title": "Add timings checkpoints",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_timings.R add_timings.Rd  Add timings checkpoints\nHelper function for storing timings information.\n add_timings(trajectory, timings) is_wrapper_with_timings(trajectory) add_timing_checkpoint(timings, name) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   timings A list of timings.\n   name The name of the timings checkpoint.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/allowed_inputs/",
	"title": "All allowed inputs",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R allowed_inputs.Rd  All allowed inputs\n allowed_inputs Format An object of class tbl_df (inherits from tbl, data.frame) with 13 rows and 2 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynwrap/other/allowed_outputs/",
	"title": "All allowed outputs",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R allowed_outputs.Rd  All allowed outputs\n allowed_outputs Format An object of class tbl_df (inherits from tbl, data.frame) with 14 rows and 5 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_angle/",
	"title": "Angle",
	"tags": [],
	"description": "",
	"content": " ti_angle.Rd  Will generate a trajectory using Angle.\nThis method was wrapped inside a container.\n ti_angle(dimred = \"pca\") Arguments   dimred Which dimensionality reduction method to use. Domain: pca, mds, tsne, ica, lle, landmark_mds, mds_sammon, mds_isomds, mds_smacof, umap, dm_diffusionMap, dm_destiny. Default: pca. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_calista/",
	"title": "CALISTA",
	"tags": [],
	"description": "",
	"content": " ti_calista.Rd  Will generate a trajectory using CALISTA.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_calista(runs = 50L, max_iter = 100L) Arguments   runs Number of independent runs of greedy algorithm. Domain: U(20, 100). Default: 50. Format: integer.\n   max_iter Number of iterations in greedy algorithm. Domain: U(20, 400). Default: 100. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Papili Gao, N., Hartmann, T., Fang, T., Gunawan, R., 2018. CALISTA: Clustering And Lineage Inference in Single-Cell Transcriptional Analysis.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynwrap/derive_trajectory/calculate_geodesic_distances/",
	"title": "Calculate geodesic distances between cells in a trajectory",
	"tags": [],
	"description": "",
	"content": " Source: R/calculate_geodesic_distances.R calculate_geodesic_distances.Rd  Will calculate geodesic distances between cells within a trajectory. To speed things up, only the distances with a set of waypoint cells are calculated.\n calculate_geodesic_distances(trajectory, waypoint_cells = NULL, waypoint_milestone_percentages = NULL) compute_tented_geodesic_distances(trajectory, waypoint_cells = NULL, waypoint_milestone_percentages = NULL) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   waypoint_cells A vector of waypoint cells. Only the geodesic distances between waypoint cells and all other cells will be calculated.\n   waypoint_milestone_percentages The milestone percentages of non-cell waypoints, containing waypoint_id, milestone_id and percentage columns\n   Details The geodesic distance takes into account the length of an edge regions of delayed commitment.\nExamples data(example_dataset) geodesic_distances \u0026lt;- calculate_geodesic_distances(example_dataset)  Contents Arguments Details Examples  -- "
},
{
	"uri": "/reference/dynwrap/derive_trajectory/calculate_average_by_milestone_percentages/",
	"title": "Calculate mean values by milestone percentages",
	"tags": [],
	"description": "",
	"content": " Source: R/calculate_average.R calculate_average_by_milestone_percentages.Rd  Calculate mean values by milestone percentages\n calculate_average_by_milestone_percentages(x, milestone_percentages) Arguments   x A matrix. One row for every cell; one column for every feature. The rows must be named.\n   milestone_percentages A data frame of milestone percentages. Format: data_frame(cell_id = character(), milestone_id = character(), percentage = numeric()).\n   Examples data(example_dataset) calculate_average_by_milestone_percentages( x = example_dataset$expression, milestone_percentages = example_dataset$milestone_percentages )#\u0026gt; 2 x 3 Matrix of class \"dgeMatrix\" #\u0026gt; A B C #\u0026gt; milestone_begin 0.08077621 4.508947 0.3344824 #\u0026gt; milestone_end 0.08442002 4.545806 0.6677499  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynwrap/derive_trajectory/calculate_average_by_group/",
	"title": "Calculate mean values per cell group",
	"tags": [],
	"description": "",
	"content": " Source: R/calculate_average.R calculate_average_by_group.Rd  Calculate mean values per cell group\n calculate_average_by_group(x, cell_grouping) Arguments   x A matrix. One row for every cell; one column for every feature. The rows must be named.\n   cell_grouping A data frame denoting the grouping of the cells. Format: data_frame(cell_id = character(), group_id = character()).\n   Examples data(example_dataset) calculate_average_by_group( x = example_dataset$expression, cell_grouping = example_dataset$prior_information$groups_id )#\u0026gt; 2 x 3 Matrix of class \"dgeMatrix\" #\u0026gt; A B C #\u0026gt; milestone_begin 0.07812584 4.501048 0.2619637 #\u0026gt; milestone_end 0.08745544 4.555942 0.7605896  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dyneval/metric/calculate_metrics/",
	"title": "Calculate the similarity between two trajectory models.",
	"tags": [],
	"description": "",
	"content": " calculate_metrics.Rd  One use case for these metrics is to calculate the accuracy of a certain prediction compared to a reference trajectory. However, these metrics can also be used for other purposes, such as clustering of trajectories.\n calculate_metrics(dataset, model, metrics = dyneval::metrics$metric_id, expression_source = dataset$expression) Arguments   dataset The first trajectory, in most cases a gold standard trajectory\n   model The second trajectory, in most cases a predicted trajectory\n   metrics Which metrics to evaluate. Check dyneval::metrics for a list of possible metrics. Passing a custom metric function with format function(dataset, model) { 1 } is also supported. The name of this function within the list will be used as the name of the metric.\n   expression_source The expression data matrix, with features as columns.\n If a matrix is provided, it is used as is.\n If a character is provided, dataset[[expression_source]] should contain the matrix.\n If a function is provided, that function will be called in order to obtain the expression (useful for lazy loading).\n    Details Some metrics are asymmetric (see dyneval::metrics$symmetric), in which case the order of the dataset and model parameters matters.\n Contents Arguments Details  -- "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/reference/dynmethods/other/ti_cellrouter/",
	"title": "CellRouter",
	"tags": [],
	"description": "",
	"content": " ti_cellrouter.Rd  Will generate a trajectory using CellRouter.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_cellrouter(ndim_pca = 20L, ndim_tsne = 11L, max_iter = 1000L, cluster_method = \"graph.clustering\", k_clustering = 20L, ndim_pca_clustering = 20L, k_knn = 10L, ndim_pca_knn = 20L, sim_type = \"jaccard\", distance_method_paths = \"graph\", ranks = \"rank\", num_cells = 3L, neighs = 3L, perplexity = 30L) Arguments   ndim_pca Number of principal components to compute. Domain: U(2, 100). Default: 20. Format: integer.\n   ndim_tsne Number of tsne dimensions to compute. Domain: U(2, 100). Default: 11. Format: integer.\n   max_iter Maximal number of tsne iterations. Domain: e^U(4.61, 11.51). Default: 1000. Format: integer.\n   cluster_method Method to use for clustering. Domain: graph.clustering, model.clustering. Default: graph.clustering. Format: character.\n   k_clustering Number of nearest neighbors to build a k-nearest neighbors graph for clustering. Domain: U(2, 1000). Default: 20. Format: integer.\n   ndim_pca_clustering Number of PCA dimensions used for k-nearest neighbors graph for clustering. Domain: U(2, 100). Default: 20. Format: integer.\n   k_knn Number of nearest neighbors to build a k-nearest neighbors graph for knn. Domain: e^U(0.69, 6.91). Default: 10. Format: integer.\n   ndim_pca_knn Number of PCA dimensions used for knn. Domain: U(2, 100). Default: 20. Format: integer.\n   sim_type Similarity type for knn. Domain: jaccard. Default: jaccard. Format: character.\n   distance_method_paths Distance method for paths. Domain: euclidean, maximum, manhattan, canberra, binary, graph. Default: graph. Format: character.\n   ranks How to rank the paths. Domain: path_cost, path_flow, rank, length. Default: rank. Format: character.\n   num_cells Trajectories should contain at least num.cells. Domain: U(3, 100). Default: 3. Format: integer.\n   neighs The size of the neighborhood in kNN graph used to smoothen kinetic profiles. Domain: U(2, 100). Default: 3. Format: integer.\n   perplexity Perplexity parameter for tsne. Domain: U(5, 100). Default: 30. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Lummertz da Rocha, E., Rowe, R.G., Lundin, V., Malleshaiah, M., Jha, D.K., Rambo, C.R., Li, H., North, T.E., Collins, J.J., Daley, G.Q., 2018. Reconstruction of complex single-cell trajectories using CellRouter. Nature Communications 9.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_celltrails/",
	"title": "CellTrails",
	"tags": [],
	"description": "",
	"content": " ti_celltrails.Rd  Will generate a trajectory using CellTrails.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_celltrails(filter_features = FALSE, threshold_dl = 2L, threshold_cov = 0.05, threshold_ff = 1.7, min_expr = 0L, frac = 100L, min_size = 0.01, min_feat = 5L, max_pval = 1e-04, min_fc = 2L, l = 10L) Arguments   filter_features Whether to include celltrails feature filtering. Default: FALSE. Format: logical.\n   threshold_dl Minimum number of samples; if value \u0026lt; 1 it is interpreted as fraction, otherwise as absolute sample count. Domain: U(0, 100). Default: 2. Format: integer.\n   threshold_cov Minimum coefficient of variation; numeric value between 0 and 1. Domain: U(0, 1). Default: 0.05. Format: numeric.\n   threshold_ff A Z-score cutoff. Domain: U(0, 5). Default: 1.7. Format: numeric.\n   min_expr Minimum average feature expression. Domain: U(0, 2). Default: 0. Format: numeric.\n   frac Fraction or number (if frac \u0026gt; 1) of eigengaps used to perform linear fit. Domain: e^U(0.00, 6.91). Default: 100. Format: numeric.\n   min_size The initial cluster dedrogram is cut at an height such that the minimum cluster size is at least min_size; if min_size \u0026lt; 1 than the fraction of total samples is used, otherwise it is used as absoulte count. Domain: e^U(-6.91, 0.00). Default: 0.01. Format: numeric.\n   min_feat Minimum number of differentially expressed features between siblings. If this number is not reached, two neighboring clusters (siblings) in the pruned dendrogram get joined. Domain: U(1, 100). Default: 5. Format: integer.\n   max_pval Maximum P-value for differential expression computation. Domain: e^U(-16.12, 0.00). Default: 1e-04. Format: numeric.\n   min_fc Mimimum fold-change for differential expression computation. Domain: U(0, 5). Default: 2. Format: numeric.\n   l Neighborhood size. Domain: U(1, 50). Default: 10. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Ellwanger, D.C., Scheibinger, M., Dumont, R.A., Barr-Gillespie, P.G., Heller, S., 2018. Transcriptional Dynamics of Hair-Bundle Morphogenesis Revealed with CellTrails. Cell Reports 23, 2901–2914.e14.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynwrap/other/classify_milestone_network/",
	"title": "Classify a milestone network",
	"tags": [],
	"description": "",
	"content": " Source: R/classify_milestone_network.R classify_milestone_network.Rd  Classify a milestone network\n classify_milestone_network(milestone_network) Arguments   milestone_network A milestone network\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/other/add_density_coloring/",
	"title": "Color cells using a background density",
	"tags": [],
	"description": "",
	"content": " add_density_coloring.Rd  Color cells using a background density\n add_density_coloring(cell_positions, color_density = c(\"none\", \"grouping\", \"feature\"), traj, grouping = NULL, groups = NULL, feature_oi = NULL, expression_source = \"expression\", padding = 0.1, nbins = 1000, bw = 0.2, density_cutoff = 0.3, density_cutoff_label = density_cutoff/10) Arguments   cell_positions The positions of the cells in 2D\n   color_density How to color density, can be \"none\", \"grouping\", or \"feature\"\n   traj The trajectory\n   grouping The grouping of the cells\n   groups Tibble containing information of the cell groups\n   feature_oi feature to plot expression\n   expression_source Source of the feature expression, defaults to `expression`\n   padding The padding in the edges to the plot, relative to the size of the plot\n   nbins Number of bins for calculating the density\n   bw Bandwidth, relative to the size of the plot\n   density_cutoff Cutoff for density, the lower the larger the areas\n   density_cutoff_label Cutoff for density for labelling, the lower the further way from cells\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dyneval/metric/calculate_featureimp_enrichment/",
	"title": "Compare enrichment in finding back the most important genes",
	"tags": [],
	"description": "",
	"content": " calculate_featureimp_enrichment.Rd  Compare enrichment in finding back the most important genes\n calculate_featureimp_enrichment(dataset, prediction, expression_source = dataset$expression, fi_method = dynfeature::fi_ranger_rf_lite()) Arguments   dataset A dataset\n   prediction A predicted trajectory\n   expression_source The expression data matrix, with features as columns.\n If a matrix is provided, it is used as is.\n If a character is provided, dataset[[expression_source]] should contain the matrix.\n If a function is provided, that function will be called in order to obtain the expression (useful for lazy loading).\n    fi_method A feature importance method. Default: fi_ranger_rf_lite(). Check ?fi_methods for a full list of available feature importance methods.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dyneval/metric/calculate_featureimp_cor/",
	"title": "Compare feature importances derived by both trajectories",
	"tags": [],
	"description": "",
	"content": " calculate_featureimp_cor.Rd  Compare feature importances derived by both trajectories\n calculate_featureimp_cor(dataset, prediction, expression_source = dataset$expression_source, fi_method = dynfeature::fi_ranger_rf_lite()) Arguments   dataset A dataset\n   prediction A predicted trajectory\n   expression_source The expression data matrix, with features as columns.\n If a matrix is provided, it is used as is.\n If a character is provided, dataset[[expression_source]] should contain the matrix.\n If a function is provided, that function will be called in order to obtain the expression (useful for lazy loading).\n    fi_method A feature importance method. Default: fi_ranger_rf_lite(). Check ?fi_methods for a full list of available feature importance methods.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dyneval/metric/calculate_mapping/",
	"title": "Compares the mapping between milestones or branches",
	"tags": [],
	"description": "",
	"content": " calculate_mapping.Rd  Compares the mapping between milestones or branches\n calculate_mapping(dataset, prediction, grouping = c(\"branches\", \"milestones\"), simplify = TRUE) calculate_mapping_milestones(dataset, prediction, simplify = TRUE) calculate_mapping_branches(dataset, prediction, simplify = TRUE) Arguments   dataset A dataset\n   prediction A predicted model\n   grouping How to group the cells, either branches or milestones\n   simplify Whether to simplify the trajectory (allowing self loops)\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_comp1/",
	"title": "Component 1",
	"tags": [],
	"description": "",
	"content": " ti_comp1.Rd  Will generate a trajectory using Component 1.\nThis method was wrapped inside a container.\n ti_comp1(dimred = \"pca\", ndim = 2L, component = 1L) Arguments   dimred Which dimensionality reduction method to use. Domain: pca, mds, tsne, ica, lle, landmark_mds, mds_sammon, mds_isomds, mds_smacof, umap, dm_diffusionMap. Default: pca. Format: character.\n   ndim . Domain: U(2, 30). Default: 2. Format: integer.\n   component . Domain: U(1, 10). Default: 1. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dyneval/metric/calculate_position_predict/",
	"title": "Compute metrics related to the prediction of the positions",
	"tags": [],
	"description": "",
	"content": " calculate_position_predict.Rd  Compute metrics related to the prediction of the positions\n calculate_position_predict(dataset, prediction, metrics = c(\"rf_mse\", \"rf_rsq\", \"lm_mse\", \"lm_rsq\")) Arguments   dataset A dataset containing a trajectory\n   prediction A predicted trajectory\n   metrics Which metrics to predict, can be rf_mse, rf_rsq, rf_nmse, lm_mse, lm_rsq and/or lm_nmse\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_cyclic_trajectory/",
	"title": "Constructs a circular trajectory using the pseudotime values of each cell.",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_cyclic_trajectory.R add_cyclic_trajectory.Rd  This function will generate the milestone_network and progressions.\n add_cyclic_trajectory(dataset, pseudotime, directed = FALSE, do_scale_minmax = TRUE, ...) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   pseudotime A named vector of pseudo times.\n   directed Whether or not the directionality of the pseudotime is predicted.\n   do_scale_minmax Whether or not to scale the pseudotime between 0 and 1. Otherwise, will assume the values are already within that range.\n   ... extra information to be stored in the wrapper.\n   Value The trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_linear_trajectory/",
	"title": "Constructs a linear trajectory using the pseudotime values of each cell.",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_linear_trajectory.R add_linear_trajectory.Rd  This function will generate the milestone_network and progressions.\n add_linear_trajectory(dataset, pseudotime, directed = FALSE, do_scale_minmax = TRUE, ...) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   pseudotime A named vector of pseudo times.\n   directed Whether or not the directionality of the pseudotime is predicted.\n   do_scale_minmax Whether or not to scale the pseudotime between 0 and 1. Otherwise, will assume the values are already within that range.\n   ... extra information to be stored in the trajectory\n   Value The trajectory\nExamples dataset \u0026lt;- dynwrap::example_dataset pseudotime \u0026lt;- data.frame(cell_id = dataset$cell_ids, pseudotime = runif(length(dataset$cell_ids))) trajectory \u0026lt;- add_linear_trajectory(dataset, pseudotime)  Contents Arguments Value Examples  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_dimred_projection/",
	"title": "Constructs a trajectory by projecting cells within a dimensionality reduction onto a backbone formed by a milestone network. Optionally, a cell grouping can be given which will restrict the edges on which a cell can be projected.",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_dimred_projection.R add_dimred_projection.Rd  This function will generate the milestone_network and progressions.\n add_dimred_projection(dataset, milestone_ids = NULL, milestone_network, dimred, dimred_milestones, grouping = NULL, ...) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   milestone_ids The ids of the milestones in the trajectory. Type: Character vector.\n   milestone_network The network of the milestones. Type: Data frame(from = character, to = character, length = numeric, directed = logical).\n   dimred The dimensionality reduction matrix (with cell_ids as rownames) or function which will run the dimensionality reduction\n   dimred_milestones An optional dimensionality reduction of the milestones.\n   grouping A grouping of the cells, can be a named vector or a dataframe with group_id (character) and cell_id (character)\n   ... extra information to be stored in the wrapper.\n   Value The trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_cluster_graph/",
	"title": "Constructs a trajectory using a cell grouping and a network between groups. Will use an existing grouping if it is present in the dataset.",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_cluster_graph.R add_cluster_graph.Rd  This function will generate the milestone_network and progressions.\n add_cluster_graph(dataset, milestone_network, grouping = NULL, explicit_splits = FALSE, ...) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   milestone_network A network of milestones.\n   grouping A grouping of the cells, can be a named vector or a dataframe with group_id (character) and cell_id (character)\n   explicit_splits Whether to make splits specific by adding a starting node. For example: A-\u0026gt;B, A-\u0026gt;C becomes A-\u0026gt;X, X-\u0026gt;B, X-\u0026gt;C\n   ... extra information to be stored in the wrapper.\n   Value The trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_cell_graph/",
	"title": "Constructs a trajectory using a graph between cells, by mapping cells onto a set of backbone cells.",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_cell_graph.R add_cell_graph.Rd  This function will generate the milestone_network and progressions.\n add_cell_graph(dataset, cell_graph, to_keep, milestone_prefix = \"milestone_\", ...) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   cell_graph The edges between cells. Format: Data frame(from = character, to = character, length(optional) = numeric, directed(optional) = logical)\n   to_keep A named vector containing booleans containing whether or not a cell is part of the backbone. Or, alternatively a character vector containing the backbone cells\n   milestone_prefix A prefix to add to the id of the cell ids when they are used as milestones, in order to avoid any naming conflicts,\n   ... extra information to be stored in the wrapper.\n   Value The trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/convert_definition/",
	"title": "Convert a definition loaded in from a yaml",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R convert_definition.Rd  Convert a definition loaded in from a yaml\n convert_definition(definition_raw) Arguments   definition_raw The raw definition loaded from the yaml\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/other/convert_milestone_percentages_to_progressions/",
	"title": "Convert milestone percentages to progressions",
	"tags": [],
	"description": "",
	"content": " Source: R/convert_milestone_percentages_to_progressions.R convert_milestone_percentages_to_progressions.Rd  Convert milestone percentages to progressions\n convert_milestone_percentages_to_progressions(cell_ids, milestone_ids, milestone_network, milestone_percentages) Arguments   cell_ids Vector of all cell ids\n   milestone_ids Vector of milestone ids\n   milestone_network Milestone network\n   milestone_percentages Milestone percentages\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/other/convert_progressions_to_milestone_percentages/",
	"title": "Convert progressions to milestone percentages",
	"tags": [],
	"description": "",
	"content": " Source: R/convert_progressions_to_milestone_percentages.R convert_progressions_to_milestone_percentages.Rd  Convert progressions to milestone percentages\n convert_progressions_to_milestone_percentages(cell_ids, milestone_ids, milestone_network, progressions) Arguments   cell_ids Vector of all cell ids\n   milestone_ids Vector of milestone ids\n   milestone_network Milestone network\n   progressions Progressions dataframe\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/create_ti_method_container/",
	"title": "Create a TI method from a docker / singularity container",
	"tags": [],
	"description": "",
	"content": " Source: R/method_create_ti_method_container.R create_ti_method_container.Rd  These functions create a TI method from a container using babelwhale. Supports both docker and singularity as a backend.\n create_ti_method_container(container_id, pull_if_needed = TRUE, return_function = TRUE) Arguments   container_id The name of the container repository (e.g. \"dynverse/ti_angle\").\n   pull_if_needed Pull the container if not yet available.\n   return_function Whether to return a function that allows you to override the default parameters, or just return the method meta data as is.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/create_ti_method_definition/",
	"title": "Create a TI method from a local method definition file",
	"tags": [],
	"description": "",
	"content": " Source: R/method_create_ti_method_definition.R create_ti_method_definition.Rd  The local method definition file describes a method that is runnable on the local system.\n create_ti_method_definition(definition, script, return_function = TRUE) Arguments   definition A definition, see definition()\n   script Location of the script that will be executed. Has to contain a #!\n   return_function Whether to return a function that allows you to override the default parameters, or just return the method meta data as is.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/create_ti_method_r/",
	"title": "Create a TI method wrapper",
	"tags": [],
	"description": "",
	"content": " Source: R/method_create_ti_method_r.R create_ti_method_r.Rd  Create a TI method wrapper\n create_ti_method_r(definition, run_fun, package_required = character(), package_loaded = character(), remotes_package = character(), return_function = TRUE) Arguments   definition A definition, see definition()\n   run_fun A function to infer a trajectory, with parameters counts/expression, parameters, priors, verbose and seed\n   package_required The packages that need to be installed before executing the method.\n   package_loaded The packages that need to be loaded before executing the method.\n   remotes_package Package from which the remote locations of dependencies have to be extracted, eg. dynmethods.\n   return_function Whether to return a function that allows you to override the default parameters, or just return the method meta data as is.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/definition/",
	"title": "Create a definition",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R definition.Rd  A definition contains meta information on a TI method and various aspects thereof. For brevity, the example only contains a minimum example, check the documentation of the def_* helper functions for more extensive examples.\n definition(method, wrapper, manuscript = NULL, container = NULL, parameters = parameter_set()) is_ti_method(method) Arguments   method Meta information on the TI method (see def_method()).\n   wrapper Meta information on the wrapper itself (see def_wrapper()).\n   manuscript Meta information on the manuscript, if applicable (see def_manuscript()).\n   container Meta information on the container in which the wrapper resides, if applicable (see def_container()).\n   parameters Meta information on the parameters of the TI method (see def_parameters()).\n   Examples library(dynparam) definition( method = def_method(id = \"some_method\"), wrapper = def_wrapper(input_required = \"expression\"), parameters = parameter_set( integer_parameter(id = \"k\", default = 5L, distribution = uniform_distribution(3L, 20L)) ) )#\u0026gt; $method #\u0026gt; $method$id #\u0026gt; [1] \"some_method\" #\u0026gt; #\u0026gt; $method$name #\u0026gt; [1] \"some_method\" #\u0026gt; #\u0026gt; $method$source #\u0026gt; [1] \"tool\" #\u0026gt; #\u0026gt; $method$tool_id #\u0026gt; NULL #\u0026gt; #\u0026gt; $method$platform #\u0026gt; NULL #\u0026gt; #\u0026gt; $method$url #\u0026gt; NULL #\u0026gt; #\u0026gt; $method$license #\u0026gt; NULL #\u0026gt; #\u0026gt; $method$authors #\u0026gt; list() #\u0026gt; #\u0026gt; #\u0026gt; $wrapper #\u0026gt; $wrapper$input_required #\u0026gt; [1] \"expression\" #\u0026gt; #\u0026gt; $wrapper$input_optional #\u0026gt; character(0) #\u0026gt; #\u0026gt; $wrapper$type #\u0026gt; [1] \"trajectory\" #\u0026gt; #\u0026gt; $wrapper$topology_inference #\u0026gt; NULL #\u0026gt; #\u0026gt; $wrapper$trajectory_types #\u0026gt; character(0) #\u0026gt; #\u0026gt; $wrapper$inputs #\u0026gt; # A tibble: 2 x 3 #\u0026gt; input_id required type #\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;lgl\u0026gt; \u0026lt;chr\u0026gt; #\u0026gt; 1 expression TRUE expression #\u0026gt; 2 k FALSE parameter #\u0026gt; #\u0026gt; #\u0026gt; $manuscript #\u0026gt; NULL #\u0026gt; #\u0026gt; $container #\u0026gt; NULL #\u0026gt; #\u0026gt; $parameters #\u0026gt; k | type=integer | domain=U(3, 20) | default=5 #\u0026gt; attr(,\"class\") #\u0026gt; [1] \"dynwrap::ti_method\" \"list\"   Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynwrap/derive_trajectory/group_from_trajectory/",
	"title": "Create a grouping from a trajectory",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_grouping.R group_from_trajectory.Rd  Grouping cells onto their edges, or grouping cells onto their nearest milestones\n group_onto_trajectory_edges(trajectory, group_template = \"{from}-\u0026gt;{to}\") group_onto_nearest_milestones(trajectory) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   group_template Processed by glue::glue to name the group\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_branch_trajectory/",
	"title": "Create a trajectory given its branch network and the pseudotime of the cells on one of the branches",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_branch_trajectory.R add_branch_trajectory.Rd  Create a trajectory given its branch network and the pseudotime of the cells on one of the branches\n add_branch_trajectory(dataset, branch_network, branches, branch_progressions, ...) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   branch_network The network between branches Type: Data frame(from = charactor, to = character)\n   branches The length and directedness of the branches Type: Data frame(branch_id = character, length = numeric, directed = logical)\n   branch_progressions Specifies the progression of a cell along a transition in the branch network. Type: Data frame(cell_id = character, branch_id = character, percentage = numeric).\n   ... extra information to be stored in the trajectory\n   Value The trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/infer_trajectory/wrap_expression/",
	"title": "Create a wrapper object with expression and counts",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_expression.R wrap_expression.Rd  Create a wrapper object with expression and counts\n wrap_expression(id = NULL, expression, counts, cell_info = NULL, feature_info = NULL, ...) Arguments   id A unique identifier for the data. If NULL, a random string will be generated.\n   expression The normalised expression values with genes in columns and cells in rows\n   counts The counts with genes in columns and cells in rows\n   cell_info Optional meta-information pertaining the cells.\n   feature_info Optional meta-information of the features, a data.frame with at least feature_id as column\n   ... extra information to be stored in the dataset\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/plot_helpers/empty_plot/",
	"title": "Create an empty plot for spacing",
	"tags": [],
	"description": "",
	"content": " empty_plot.Rd  Create an empty plot for spacing\n empty_plot()  Contents  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_dpt/",
	"title": "DPT",
	"tags": [],
	"description": "",
	"content": " ti_dpt.Rd  Will generate a trajectory using DPT.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_dpt(sigma = \"local\", distance = \"euclidean\", ndim = 20L, density_norm = TRUE, n_local = c(5L, 7L), w_width = 0.1) Arguments   sigma Diffusion scale parameter of the Gaussian kernel. A larger sigma might be necessary if the eigenvalues can not be found because of a singularity in the matrix. Must a character vector -- \"local\" (default) or \"global\". Domain: local, global. Default: local. Format: character.\n   distance A character vector specifying which distance metric to use. Allowed measures are the Euclidean distance (default), the cosine distance (1-corr(c_1, c_2)), or the rank correlation distance (1-corr(rank(c_1), rank(c_2))). Domain: euclidean, cosine, rankcor. Default: euclidean. Format: character.\n   ndim Number of eigenvectors/dimensions to return. Domain: U(3, 100). Default: 20. Format: integer.\n   density_norm Logical. If TRUE, use density normalisation. Default: TRUE. Format: logical.\n   n_local If sigma == 'local', the n_local nearest neighbor(s) determine(s) the local sigma. Domain: ( U(2, 20), U(2, 20) ). Default: (5, 7). Format: integer_range.\n   w_width Window width to use for deciding the branch cutoff. Domain: e^U(-9.21, 0.00). Default: 0.1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Haghverdi, L., Büttner, M., Wolf, F.A., Buettner, F., Theis, F.J., 2016. Diffusion pseudotime robustly reconstructs lineage branching. Nature Methods 13, 845–848.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynplot/plot_helpers/process_dynplot/",
	"title": "Default theme for TI plots",
	"tags": [],
	"description": "",
	"content": " process_dynplot.Rd  Default theme for TI plots\n process_dynplot(g, id = NULL, expand = TRUE) Arguments   g A ggplot to modify\n   id The title\n   expand Whether or not to leave space at the borders\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_trajectory/",
	"title": "Define a trajectory dataset given its milestone network and milestone percentages or progressions",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_trajectory.R add_trajectory.Rd  Define a trajectory dataset given its milestone network and milestone percentages or progressions\n add_trajectory(dataset, milestone_ids = NULL, milestone_network, divergence_regions = NULL, milestone_percentages = NULL, progressions = NULL, allow_self_loops = FALSE, ...) is_wrapper_with_trajectory(trajectory) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   milestone_ids The ids of the milestones in the trajectory. Type: Character vector.\n   milestone_network The network of the milestones. Type: Data frame(from = character, to = character, length = numeric, directed = logical).\n   divergence_regions A data frame specifying the divergence regions between milestones (e.g. a bifurcation). Type: Data frame(divergence_id = character, milestone_id = character, is_start = logical).\n   milestone_percentages A data frame specifying what percentage milestone each cell consists of. Type: Data frame(cell_id = character, milestone_id = character, percentage = numeric).\n   progressions Specifies the progression of a cell along a transition in the milestone_network. Type: Data frame(cell_id = character, from = character, to = character, percentage = numeric).\n   allow_self_loops Whether to allow self loops Type: Logical\n   ... extra information to be stored in the dataset\n   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   Value The trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/def_method/",
	"title": "Define meta information on the TI method.",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R def_method.Rd  Define meta information on the TI method.\n def_method(id, name = id, source = \"tool\", tool_id = NULL, platform = NULL, url = NULL, license = NULL, authors = list()) Arguments   id An id by which to identify a method. Should only contain lowercase letters or underscores.\n   name The name of the method.\n   source The type of TI method. Options are :\n \"tool\": a published TI method (peer-reviewed or preprint) (default),\n \"adaptation\": an adaptation of a published method,\n \"offtheshelf\": a method constructed from off-the-shelf algorithms,\n \"control\": a control TI method (so not actually a TI method).\n    tool_id If there are multiple TI methods from the same toolkit, the name of the toolkit can be specified here.\n   platform The platform the TI method uses (e.g. R, Python, C++, ...).\n   url An URL to the codebase of the method.\n   license The software license the method uses (e.g. GPL-3, BSD-3, Artistic-2.0, MIT).\n   authors A list of authors (see example).\n   Examples def_method( id = \"some_method\", name = \"Some method \u0026lt;3\", source = \"tool\", tool_id = \"bobstoolkit\", platform = \"VBA\", url = \"https://github.com/bobdylan/singlecellvba\", license = \"GPL-3\", authors = list( def_author( given = \"Bob\", family = \"Dylan\", email = \"bob@dylan.com\", github = \"bobdylan\", orcid = \"0000-0003-1234-5678\" ) ) )#\u0026gt; $id #\u0026gt; [1] \"some_method\" #\u0026gt; #\u0026gt; $name #\u0026gt; [1] \"Some method \u0026lt;3\" #\u0026gt; #\u0026gt; $source #\u0026gt; [1] \"tool\" #\u0026gt; #\u0026gt; $tool_id #\u0026gt; [1] \"bobstoolkit\" #\u0026gt; #\u0026gt; $platform #\u0026gt; [1] \"VBA\" #\u0026gt; #\u0026gt; $url #\u0026gt; [1] \"https://github.com/bobdylan/singlecellvba\" #\u0026gt; #\u0026gt; $license #\u0026gt; [1] \"GPL-3\" #\u0026gt; #\u0026gt; $authors #\u0026gt; $authors[[1]] #\u0026gt; $authors[[1]]$given #\u0026gt; [1] \"Bob\" #\u0026gt; #\u0026gt; $authors[[1]]$family #\u0026gt; [1] \"Dylan\" #\u0026gt; #\u0026gt; $authors[[1]]$email #\u0026gt; [1] \"bob@dylan.com\" #\u0026gt; #\u0026gt; $authors[[1]]$github #\u0026gt; [1] \"bobdylan\" #\u0026gt; #\u0026gt; $authors[[1]]$orcid #\u0026gt; [1] \"0000-0003-1234-5678\" #\u0026gt; #\u0026gt; #\u0026gt;   Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynwrap/other/determine_cell_trajectory_positions/",
	"title": "Determine the positions of all cells in the trajectory",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_cell_waypoints.R determine_cell_trajectory_positions.Rd  Determine the positions of all cells in the trajectory\n determine_cell_trajectory_positions(milestone_ids, milestone_network, milestone_percentages, progressions, divergence_regions) Arguments   milestone_ids The ids of the milestones in the trajectory. Type: Character vector.\n   milestone_network The network of the milestones. Type: Data frame(from = character, to = character, length = numeric, directed = logical).\n   milestone_percentages A data frame specifying what percentage milestone each cell consists of. Type: Data frame(cell_id = character, milestone_id = character, percentage = numeric).\n   progressions Specifies the progression of a cell along a transition in the milestone_network. Type: Data frame(cell_id = character, from = character, to = character, percentage = numeric).\n   divergence_regions A data frame specifying the divergence regions between milestones (e.g. a bifurcation). Type: Data frame(divergence_id = character, milestone_id = character, is_start = logical).\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dyneval/metric/calculate_edge_flip/",
	"title": "Edge flip score",
	"tags": [],
	"description": "",
	"content": " calculate_edge_flip.Rd  Edge flip score\n calculate_edge_flip(net1, net2, return = c(\"score\", \"all\"), simplify = TRUE, limit_flips = 5, limit_combinations = choose(25, 4)) Arguments   net1 Network 1\n   net2 Network 2\n   return Whether to return only the score or the full output (all)\n   simplify Whether or not to simplify the networks\n   limit_flips Maximal number of flips to check\n   limit_combinations Maximal number of combinations to check\n   Examples net1 \u0026lt;- dyntoy::generate_milestone_network(\"linear\") net2 \u0026lt;- dyntoy::generate_milestone_network(\"bifurcating\") calculate_edge_flip(net1, net2)#\u0026gt; Error in calculate_edge_flip(net1, net2): could not find function \"calculate_edge_flip\"net1 \u0026lt;- dyntoy::generate_milestone_network(\"cyclic\") net2 \u0026lt;- dyntoy::generate_milestone_network(\"diverging_with_loops\") calculate_edge_flip(net1, net2)#\u0026gt; Error in calculate_edge_flip(net1, net2): could not find function \"calculate_edge_flip\"  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_elpigraph/",
	"title": "ElPiGraph",
	"tags": [],
	"description": "",
	"content": " ti_elpigraph.Rd  Will generate a trajectory using ElPiGraph.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_elpigraph(topology = \"tree\", NumNodes = 50L, NumEdges = 100000L, InitNodes = 2L, Mu = 0.1, Lambda = 0.01, MaxNumberOfIterations = 10L, eps = 0.01, CenterData = FALSE) Arguments   topology The kind of topology to detect. Domain: cycle, tree, linear. Default: tree. Format: character.\n   NumNodes The number of nodes of the principal graph. Domain: U(2, 1000). Default: 50. Format: integer.\n   NumEdges The maximum number of edges. Domain: e^U(0.69, 11.51). Default: 100000. Format: integer.\n   InitNodes Number of points to include in the initial graph. Domain: e^U(0.69, 6.91). Default: 2. Format: integer.\n   Mu Controls the elastic energy. Domain: e^U(-6.91, 0.00). Default: 0.1. Format: numeric.\n   Lambda Controls the elastic energy. Domain: e^U(-6.91, 0.00). Default: 0.01. Format: numeric.\n   MaxNumberOfIterations Maximum number of steps to embed the nodes. Domain: e^U(0.00, 6.91). Default: 10. Format: integer.\n   eps Minimal relative change in the position of the nodes to stop embedment. Domain: e^U(-6.91, 0.00). Default: 0.01. Format: numeric.\n   CenterData Should data and initial node positions be centered?. Default: FALSE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_elpicycle/",
	"title": "ElPiGraph - Cycle",
	"tags": [],
	"description": "",
	"content": " ti_elpicycle.Rd  Will generate a trajectory using ElPiGraph - Cycle.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_elpicycle(NumNodes = 50L, NumEdges = 100000L, InitNodes = 2L, Mu = 0.1, Lambda = 0.01, MaxNumberOfIterations = 10L, eps = 0.01, CenterData = FALSE) Arguments   NumNodes The number of nodes of the principal graph. Domain: U(2, 1000). Default: 50. Format: integer.\n   NumEdges The maximum number of edges. Domain: e^U(0.69, 11.51). Default: 100000. Format: integer.\n   InitNodes Number of points to include in the initial graph. Domain: e^U(0.69, 6.91). Default: 2. Format: integer.\n   Mu Controls the elastic energy. Domain: e^U(-6.91, 0.00). Default: 0.1. Format: numeric.\n   Lambda Controls the elastic energy. Domain: e^U(-6.91, 0.00). Default: 0.01. Format: numeric.\n   MaxNumberOfIterations Maximum number of steps to embed the nodes. Domain: e^U(0.00, 6.91). Default: 10. Format: integer.\n   eps Minimal relative change in the position of the nodes to stop embedment. Domain: e^U(-6.91, 0.00). Default: 0.01. Format: numeric.\n   CenterData Should data and initial node positions be centered?. Default: FALSE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_elpilinear/",
	"title": "ElPiGraph - Linear",
	"tags": [],
	"description": "",
	"content": " ti_elpilinear.Rd  Will generate a trajectory using ElPiGraph - Linear.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_elpilinear(NumNodes = 50L, NumEdges = 100000L, InitNodes = 2L, Mu = 0.1, Lambda = 0.01, MaxNumberOfIterations = 10L, eps = 0.01, CenterData = FALSE) Arguments   NumNodes The number of nodes of the principal graph. Domain: U(2, 1000). Default: 50. Format: integer.\n   NumEdges The maximum number of edges. Domain: e^U(0.69, 11.51). Default: 100000. Format: integer.\n   InitNodes Number of points to include in the initial graph. Domain: e^U(0.69, 6.91). Default: 2. Format: integer.\n   Mu Controls the elastic energy. Domain: e^U(-6.91, 0.00). Default: 0.1. Format: numeric.\n   Lambda Controls the elastic energy. Domain: e^U(-6.91, 0.00). Default: 0.01. Format: numeric.\n   MaxNumberOfIterations Maximum number of steps to embed the nodes. Domain: e^U(0.00, 6.91). Default: 10. Format: integer.\n   eps Minimal relative change in the position of the nodes to stop embedment. Domain: e^U(-6.91, 0.00). Default: 0.01. Format: numeric.\n   CenterData Should data and initial node positions be centered?. Default: FALSE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_embeddr/",
	"title": "Embeddr",
	"tags": [],
	"description": "",
	"content": " ti_embeddr.Rd  Will generate a trajectory using Embeddr.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_embeddr(ndim = 2L, kernel = \"nn\", metric = \"correlation\", nn_pct = 0L, eps = 0L, t = 0L, symmetrize = \"mean\", measure_type = \"unorm\", thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \"smooth.spline\") Arguments   ndim Dimension of the embedded space, default is 2. Domain: U(2, 10). Default: 2. Format: integer.\n   kernel The choice of kernel. 'nn' will give nearest neighbours, 'dist' gives minimum distance and'heat' gives a heat kernel. Discussed in detail in 'Laplacian Eigenmaps and Spectral Techniques for Embedding and Clustering',Belkin \u0026amp; Niyogi. Domain: nn, dist, heat. Default: nn. Format: character.\n   metric The metric with which to assess 'closeness' for nearest neighbour selection, one of'correlation' (pearson) or 'euclidean'. Default is 'correlation'. Domain: correlation, euclidean, cosine. Default: correlation. Format: character.\n   nn_pct The percentage of cells to use as tge number of nearest neighbours if kernel == 'nn'. Domain: U(-2, 1). Default: 0. Format: numeric.\n   eps Maximum distance parameter if kernel == 'dist'. Domain: U(-5, 5). Default: 0. Format: numeric.\n   t \"time\" for heat kernel if kernel == \"heat\". Domain: U(-5, 5). Default: 0. Format: numeric.\n   symmetrize How to make the adjacency matrix symmetric. Note that slightlycounterintuitively, node i having node j as a nearest neighbour doesn't guarantee nodej has node i. There are several ways to get round this;* mean If the above case occurs make the link weight 0.5 so the adjacency matrix becomes $0.5(A + A')$* ceil If the above case occurs set the link weight to 1 (ie take the ceiling of the mean case)* floor If the above case occurs set the link weight to 0 (ie take the floor of the mean case). Domain: mean, ceil, floor. Default: mean. Format: character.\n   measure_type Type of laplacian eigenmap, which corresponds to the constraint on the eigenvalue problem. Iftype is 'unorm' (default), then the graph measure used is the identity matrix, while if type is 'norm' then the measureused is the degree matrix. Domain: unorm, norm. Default: unorm. Format: character.\n   thresh Convergence threshold on shortest distances to the curve. Domain: e^U(-11.51, 11.51). Default: 0.001. Format: numeric.\n   maxit Maximum number of iterations. Domain: U(0, 50). Default: 10. Format: integer.\n   stretch A factor by which the curve can be extrapolated when points are projected. Default is 2 (times the last segment length). The default is 0 for smoother equal to \"periodic_lowess\". Domain: U(0, 5). Default: 2. Format: numeric.\n   smoother Choice of smoother. The default is \"smooth_spline\", and other choices are \"lowess\" and \"periodic_lowess\". The latter allows one to fit closed curves. Beware, you may want to use iter = 0 with lowess(). Domain: smooth.spline, lowess, periodic.lowess. Default: smooth.spline. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Campbell, K., Ponting, C.P., Webber, C., 2015. Laplacian eigenmaps and principal curves for high resolution pseudotemporal ordering of single-cell RNA-seq profiles.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_error/",
	"title": "Error",
	"tags": [],
	"description": "",
	"content": " ti_error.Rd  Will generate a trajectory using Error.\nThis method was wrapped inside a container.\n ti_error(dummy_param = 0.5) Arguments   dummy_param Dummy parameter. Domain: U(0, 1). Default: 0.5. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dyneval/other/dyneval/",
	"title": "Evaluating trajectory inference methods",
	"tags": [],
	"description": "",
	"content": " dyneval.Rd  Evaluating trajectory inference methods\n  Contents  -- "
},
{
	"uri": "/reference/dynwrap/other/example_dataset/",
	"title": "Example dataset",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R example_dataset.Rd  Example dataset\n example_dataset Format An object of class dynwrap::with_cell_waypoints (inherits from dynwrap::with_prior, dynwrap::with_dimred, dynwrap::with_trajectory, dynwrap::with_expression, dynwrap::data_wrapper, list) of length 20.\n Contents Format  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_forks/",
	"title": "FORKS",
	"tags": [],
	"description": "",
	"content": " ti_forks.Rd  Will generate a trajectory using FORKS.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_forks(norm_function = \"median\", norm_quantile = 75L, cum_sum_exp_var = 0.9, cluster = c(4L, 10L), mapping_type = \"Isomap\", initialization = \"kmeans\", iterMax = 1000L, eta = 0.01, C = 1L) Arguments   norm_function No description provided by the author. Domain: mean, median, quantile. Default: median. Format: character.\n   norm_quantile No description provided by the author. Domain: U(0, 100). Default: 75. Format: numeric.\n   cum_sum_exp_var No description provided by the author. Domain: U(0, 1). Default: 0.9. Format: numeric.\n   cluster No description provided by the author. Domain: ( U(3, 20), U(3, 20) ). Default: (4, 10). Format: integer_range.\n   mapping_type No description provided by the author. Domain: Isomap, MDS, PCA, RandomForest, SpectralEmbedding, LLE_standard, tSNE. Default: Isomap. Format: character.\n   initialization No description provided by the author. Domain: kmeans, kmedoids, random. Default: kmeans. Format: character.\n   iterMax No description provided by the author. Domain: e^U(4.61, 11.51). Default: 1000. Format: integer.\n   eta No description provided by the author. Domain: e^U(-9.21, 4.61). Default: 0.01. Format: numeric.\n   C No description provided by the author. Domain: e^U(-9.21, 6.91). Default: 1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Sharma, M., Li, H., Sengupta, D., Prabhakar, S., Jayadeva, J., 2017. FORKS: Finding Orderings Robustly using K-means and Steiner trees.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_fateid/",
	"title": "FateID",
	"tags": [],
	"description": "",
	"content": " ti_fateid.Rd  Will generate a trajectory using FateID.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_fateid(reclassify = TRUE, clthr = 0.9, nbfactor = 5L, q = 0.75, k = 3L, m = \"tsne\", minnr = 5L, minnrh = 10L, trthr = 0.4, force = FALSE) Arguments   reclassify Whether to reclassify the cell grouping. Default: TRUE. Format: logical.\n   clthr Real number between zero and one. This is the threshold for the fraction of random forest votes required to assign a cell not contained within the target clusters to one of these clusters. The value of this parameter should be sufficiently high to only reclassify cells with a high-confidence assignment. Default value is 0.9. Domain: U(0.1, 1). Default: 0.9. Format: numeric.\n   nbfactor Positive integer number. Determines the number of trees grown for each random forest. The number of trees is given by the number of columns of th training set multiplied by nbfactor. Default value is 5. Domain: U(2, 100). Default: 5. Format: integer.\n   q Q real value between zero and one. This number specifies a threshold used for feature selection based on importance sampling. A reduced expression table is generated containing only features with an importance larger than the q-quantile for at least one of the classes (i. e. target clusters). Default value is 0.75. Domain: U(0, 1). Default: 0.75. Format: numeric.\n   k Number of dimensions. Domain: U(2, 100). Default: 3. Format: integer.\n   m Dimensionality reduction method to use. Can be tsne, cmd, dm or lle. Domain: tsne, cmd, dm, lle. Default: tsne. Format: character.\n   minnr Integer number of cells per target cluster to be selected for classification (test set) in each round of training. For each target cluster, the minnr cells with the highest similarity to a cell in the training set are selected for classification. If z is not NULL it is used as the similarity matrix for this step. Otherwise, 1-cor(x) is used. Default value is 5. Domain: U(2, 100). Default: 5. Format: integer.\n   minnrh Integer number of cells from the training set used for classification. From each training set, the minnrh cells with the highest similarity to the training set are selected. If z is not NULL it is used as the similarity matrix for this step. Default value is 10. Domain: U(2, 100). Default: 10. Format: integer.\n   trthr Real value representing the threshold of the fraction of random forest votes required for the inclusion of a given cell for the computation of the principal curve. If NULL then only cells with a significant bias \u0026gt;1 are included for each trajectory. The bias is computed as the ratio of the number of votes for a trajectory and the number of votes for the trajectory with the second largest number of votes. By this means only the trajectory with the largest number of votes will receive a bias \u0026gt;1. The siginifcance is computed based on counting statistics on the difference in the number of votes. A significant bias requires a p-value \u0026lt; 0.05. Domain: U(0, 1). Default: 0.4. Format: numeric.\n   force Do not use! This is a parameter to force FateID to run on benchmark datasets where not enough end groups are present. Default: FALSE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Herman, J.S., Sagar, Grün, D., 2018. FateID infers cell fate bias in multipotent progenitors from single-cell RNA-seq data. Nature Methods 15, 379–386.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_gng/",
	"title": "GNG",
	"tags": [],
	"description": "",
	"content": " ti_gng.Rd  Will generate a trajectory using GNG.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_gng(dimred = \"landmark_mds\", ndim = 5L, max_iter = 15000L, max_nodes = 8L, apply_mst = TRUE) Arguments   dimred Which dimensionality reduction method to use. Domain: pca, mds, tsne, ica, lle, landmark_mds, mds_sammon, mds_isomds, mds_smacof, umap, dm_diffusionMap. Default: landmark_mds. Format: character.\n   ndim The number of dimensions. Domain: U(2, 10). Default: 5. Format: integer.\n   max_iter The max number of iterations. Domain: e^U(3.22, 13.82). Default: 15000. Format: numeric.\n   max_nodes The maximum number of nodes. Domain: U(2, 30). Default: 8. Format: integer.\n   apply_mst If true, an MST post-processing of the GNG is performed. Default: TRUE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_gpfates/",
	"title": "GPfates",
	"tags": [],
	"description": "",
	"content": " ti_gpfates.Rd  Will generate a trajectory using GPfates.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_gpfates(log_expression_cutoff = 0.5, min_cells_expression_cutoff = 0L, ndim = 2L) Arguments   log_expression_cutoff The log expression cutoff. Domain: U(0.5, 5). Default: 0.5. Format: numeric.\n   min_cells_expression_cutoff The min expression cutoff. Domain: U(0, 20). Default: 0. Format: numeric.\n   ndim Number of dimensions for dimensionality reduction. Domain: U(1, 5). Default: 2. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Lönnberg, T., Svensson, V., James, K.R., Fernandez-Ruiz, D., Sebina, I., Montandon, R., Soon, M.S.F., Fogg, L.G., Nair, A.S., Liligeto, U.N., Stubbington, M.J.T., Ly, L.-H., Bagger, F.O., Zwiessele, M., Lawrence, N.D., Souza-Fonseca-Guimaraes, F., Bunn, P.T., Engwerda, C.R., Heath, W.R., Billker, O., Stegle, O., Haque, A., Teichmann, S.A., 2017. Single-cell RNA-seq and computational analysis using temporal mixture modeling resolves TH1/TFHfate bifurcation in malaria. Science Immunology 2, eaal2192.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynwrap/other/random_seed/",
	"title": "Generate a random seed",
	"tags": [],
	"description": "",
	"content": " Source: R/method_infer_trajectory.R random_seed.Rd  ... From the current seed.\n random_seed()  Contents  -- "
},
{
	"uri": "/reference/dynwrap/other/generate_parameter_documentation/",
	"title": "Generate the parameter documentation of a method, use with &lt;code&gt;@eval&lt;/code&gt;",
	"tags": [],
	"description": "",
	"content": " Source: R/method_create_ti_method_r.R generate_parameter_documentation.Rd  Generate the parameter documentation of a method, use with @eval\n generate_parameter_documentation(definition) Arguments   definition The definition which contain the parameters\n   Value A character vector containing the roxygen tags\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/get_default_parameters/",
	"title": "Get the default parameters of a method",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R get_default_parameters.Rd  Get the default parameters of a method\n get_default_parameters(definition) Arguments   definition A TI method description\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/plot_helpers/milestone_palette/",
	"title": "Get the names of valid color palettes",
	"tags": [],
	"description": "",
	"content": " get_milestone_palette_names.Rd  Get the names of valid color palettes\n milestone_palette(name, n) get_milestone_palette_names() Arguments   name The name of the palette. Must be one of \"cubeHelix\", \"Set3\", or \"rainbow\".\n   n The number of colours to be in the palette.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_grandprix/",
	"title": "GrandPrix",
	"tags": [],
	"description": "",
	"content": " ti_grandprix.Rd  Will generate a trajectory using GrandPrix.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_grandprix(n_inducing_points = 40L, latent_prior_var = 0.1, latent_var = 0.028) Arguments   n_inducing_points . Domain: U(0, 1). Default: 40. Format: integer.\n   latent_prior_var . Domain: U(0, 1). Default: 0.1. Format: numeric.\n   latent_var . Domain: U(0, 1). Default: 0.028. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Ahmed, S., Rattray, M., Boukouvalas, A., 2017. GrandPrix: Scaling up the Bayesian GPLVM for single-cell data.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynwrap/other/get_divergence_triangles/",
	"title": "Helper function for processing divergence regions",
	"tags": [],
	"description": "",
	"content": " Source: R/get_divergence_triangles.R get_divergence_triangles.Rd  This function returns the combinations between the start of each divergence region and pairwise combinations of the end milestones.\n get_divergence_triangles(divergence_regions) Arguments   divergence_regions A divergence regions data frame as produced by add_trajectory.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_identity/",
	"title": "Identity",
	"tags": [],
	"description": "",
	"content": " ti_identity.Rd  Will generate a trajectory using Identity.\nThis method was wrapped inside a container.\n ti_identity() Value A TI method wrapper to be used together with infer_trajectory\n Contents Value  -- "
},
{
	"uri": "/reference/dynwrap/infer_trajectory/infer_trajectories/",
	"title": "Infer trajectories",
	"tags": [],
	"description": "",
	"content": " Source: R/method_infer_trajectory.R infer_trajectories.Rd  Infer trajectories\n infer_trajectories(dataset, method, parameters = NULL, give_priors = NULL, seed = random_seed(), verbose = FALSE, return_verbose = FALSE, debug = FALSE, map_fun = map) infer_trajectory(dataset, method, parameters = NULL, give_priors = NULL, seed = random_seed(), verbose = FALSE, return_verbose = FALSE, debug = FALSE, ...) Arguments   dataset One or more datasets as created by infer_trajectory() or add_trajectory(). Prior information can be added using add_prior_information().\n   method One or more methods. Must be one of:\n an object or list of ti_... objects (eg. dynmethods::ti_comp1()),\n a character vector containing the names of methods to execute (e.g. \"scorpius\"),\n a character vector containing dockerhub repositories (e.g. dynverse/paga), or\n a dynguidelines data frame.\n    parameters A set of parameters to be used during trajectory inference. A parameter set must be a named list of parameters. If multiple methods were provided in the method parameter, parameters must be an unnamed list of the same length.\n   give_priors All the priors a method is allowed to receive. Must be a subset of all available priors (dynwrap::priors).\n   seed A seed to be passed to the TI method.\n   verbose Whether or not to print information output.\n   return_verbose Whether to store and return messages printed by the method.\n   debug Used for debugging containers methods.\n   map_fun A map function to use when inferring trajectories with multiple datasets or methods. Allows to parallellise the execution in an arbitrary way.\n   ... Any additional parameters given to the method, will be concatednated to the parameters argument\n   Value infer_trajectory: A trajectory\ninfer_trajectories: A tibble containing the dataset and method identifiers, the trajectory model and a summary containing the execution times, output and errors if appropriate\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/label_milestones/",
	"title": "Label milestones either manually (&lt;code&gt;label_milestones&lt;/code&gt;) or using marker genes (&lt;code&gt;label_milestones_markers&lt;/code&gt;)",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_label_milestones.R label_milestones.Rd  Label milestones either manually (label_milestones) or using marker genes (label_milestones_markers)\n label_milestones(trajectory, labelling) label_milestones_markers(trajectory, markers, expression_source = \"expression\", n_nearest_cells = 20) is_wrapper_with_milestone_labelling(trajectory) get_milestone_labelling(trajectory, label_milestones = NULL) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   labelling Named character vector containing for a milestone a new label\n   markers List containing for each label a list of marker genes\n   expression_source The expression source\n   n_nearest_cells The number of nearest cells to use for extracting milestone expression\n   label_milestones How to label the milestones. Can be TRUE (in which case the labels within the trajectory will be used), \"all\" (in which case both given labels and milestone_ids will be used), a named character vector, or FALSE\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/derive_trajectory/calculate_trajectory_dimred/",
	"title": "Layout the trajectory and its cells in 2 dimensions",
	"tags": [],
	"description": "",
	"content": " Source: R/calculate_trajectory_dimred.R calculate_trajectory_dimred.Rd  Layout the trajectory and its cells in 2 dimensions\n calculate_trajectory_dimred(trajectory, adjust_weights = FALSE) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   adjust_weights Whether or not to rescale the milestone network weights\n   See also wrap_data\n  Contents Arguments See also  -- "
},
{
	"uri": "/reference/dynplot/other/linearise_cells/",
	"title": "Linearise a trajectory",
	"tags": [],
	"description": "",
	"content": " linearise_cells.Rd  Linearise a trajectory\n linearise_cells(traj, margin = 0.05, no_margin_between_linear = TRUE, one_edge = FALSE, equal_cell_width = FALSE) Arguments   traj The trajectory\n   margin The margin to add\n   no_margin_between_linear Whether to add a margin only when\n   one_edge If TRUE, assigns each cell to one edge only\n   equal_cell_width if TRUE, will give each cell equal width\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_matcher/",
	"title": "MATCHER",
	"tags": [],
	"description": "",
	"content": " ti_matcher.Rd  Will generate a trajectory using MATCHER.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_matcher(quantiles = 50L, method = \"linear\") Arguments   quantiles Quantiles How many quantiles to use when computing warp functions (integer). Domain: U(2, 500). Default: 50. Format: integer.\n   method Gaussian process regression or linear interpolation? (\"gp\" or \"linear). Domain: gp, linear. Default: linear. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Welch, J.D., Hartemink, A.J., Prins, J.F., 2017. MATCHER: manifold alignment reveals correspondence between single cell transcriptome and epigenome dynamics. Genome Biology 18.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_merlot/",
	"title": "MERLoT",
	"tags": [],
	"description": "",
	"content": " ti_merlot.Rd  Will generate a trajectory using MERLoT.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_merlot(sigma = \"local\", distance = \"euclidean\", ndim = 20L, density_norm = TRUE, n_local = c(5L, 7L), w_width = 0.01, n_components_to_use = 3L, N_yk = 100L, lambda_0 = 8e-10, mu_0 = 0.0025, increaseFactor_mu = 20L, increaseFactor_lambda = 20L, FixEndpoints = FALSE) Arguments   sigma Diffusion scale parameter of the Gaussian kernel. A larger sigma might be necessary if the eigenvalues can not be found because of a singularity in the matrix. Must a character vector -- \"local\" (default) or \"global\". Domain: local, global. Default: local. Format: character.\n   distance A character vector specifying which distance metric to use. Allowed measures are the Euclidean distance (default), the cosine distance (1-corr(c_1, c_2)), or the rank correlation distance (1-corr(rank(c_1), rank(c_2))). Domain: euclidean, cosine, rankcor. Default: euclidean. Format: character.\n   ndim Number of eigenvectors/dimensions to return. Domain: U(2, 20). Default: 20. Format: integer.\n   density_norm Logical. If TRUE, use density normalisation. Default: TRUE. Format: logical.\n   n_local If sigma == 'local', the n_local nearest neighbor(s) determine(s) the local sigma. Domain: ( U(2, 20), U(2, 20) ). Default: (5, 7). Format: integer_range.\n   w_width Window width to use for deciding the branch cutoff. Domain: e^U(-9.21, 0.00). Default: 0.01. Format: numeric.\n   n_components_to_use Which components to use in downstream analysis. Domain: U(2, 20). Default: 3. Format: integer.\n   N_yk Number of nodes for the elastic principal tree. Domain: U(2, 1000). Default: 100. Format: integer.\n   lambda_0 Principal elastic tree energy function parameter. Domain: e^U(-27.63, -13.82). Default: 8e-10. Format: numeric.\n   mu_0 Principal elastic tree energy function parameter. Domain: U(5e-04, 0.005). Default: 0.0025. Format: numeric.\n   increaseFactor_mu Factor by which the mu will be increased for the embedding. Domain: U(2, 50). Default: 20. Format: numeric.\n   increaseFactor_lambda Factor by which the mu will be increased for the embedding. Domain: U(2, 50). Default: 20. Format: numeric.\n   FixEndpoints Documentation not provided by authors. Default: FALSE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Parra, R.G., Papadopoulos, N., Ahumada-Arranz, L., El Kholtei, J., Mottelson, N., Horokhovskyi, Y., Treutlein, B., Soeding, J., 2018. Reconstructing complex lineage trees from scRNA-seq data using MERLoT.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_mfa/",
	"title": "MFA",
	"tags": [],
	"description": "",
	"content": " ti_mfa.Rd  Will generate a trajectory using MFA.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_mfa(iter = 2000L, thin = 1L, pc_initialise = 1L, prop_collapse = 0L, scale_input = TRUE, zero_inflation = FALSE) Arguments   iter Number of MCMC iterations. Domain: U(20, 5000). Default: 2000. Format: integer.\n   thin MCMC samples to thin. Domain: U(1, 20). Default: 1. Format: integer.\n   pc_initialise Which principal component to initialise pseudotimes to. Domain: U(1, 5). Default: 1. Format: integer.\n   prop_collapse Proportion of Gibbs samples which should marginalise over c. Domain: U(0, 1). Default: 0. Format: numeric.\n   scale_input Logical. If true, input is scaled to have mean 0 variance 1. Default: TRUE. Format: logical.\n   zero_inflation Logical, should zero inflation be enabled?. Default: FALSE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Campbell, K.R., Yau, C., 2017. Probabilistic modeling of bifurcations in single-cell gene expression data using a Bayesian mixture of factor analyzers. Wellcome Open Research 2, 19.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_mst/",
	"title": "MST",
	"tags": [],
	"description": "",
	"content": " ti_mst.Rd  Will generate a trajectory using MST.\nThis method was wrapped inside a container.\n ti_mst(dimred = \"pca\", ndim = 2L) Arguments   dimred Which dimensionality reduction method to use. Domain: pca, mds, tsne, ica, lle, landmark_mds, mds_sammon, mds_isomds, mds_smacof, umap, dm_diffusionMap. Default: pca. Format: character.\n   ndim . Domain: U(2, 30). Default: 2. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/def_author/",
	"title": "Meta information on an author",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R def_author.Rd  Meta information on an author\n def_author(given, family, email = NULL, github = NULL, orcid = NULL) Arguments   given The given name\n   family The family name\n   email The email address\n   github The github handle\n   orcid The orcid id\n   Examples def_author( given = \"Bob\", family = \"Dylan\", email = \"bob@dylan.com\", github = \"bobdylan\", orcid = \"0000-0003-1234-5678\" )#\u0026gt; $given #\u0026gt; [1] \"Bob\" #\u0026gt; #\u0026gt; $family #\u0026gt; [1] \"Dylan\" #\u0026gt; #\u0026gt; $email #\u0026gt; [1] \"bob@dylan.com\" #\u0026gt; #\u0026gt; $github #\u0026gt; [1] \"bobdylan\" #\u0026gt; #\u0026gt; $orcid #\u0026gt; [1] \"0000-0003-1234-5678\" #\u0026gt;   Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/def_container/",
	"title": "Meta information on the container in which the wrapper resides",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R def_container.Rd  Meta information on the container in which the wrapper resides\n def_container(docker, url = NULL) Arguments   docker The handle of the docker container\n   url An url of where the docker codebase resides (containing definition.yml, Dockerfile, ...)\n   Examples def_container( docker = \"bobdylan/ti_some_method\", url = \"https://github.com/bobdylan/ti_some_method\" )#\u0026gt; $docker #\u0026gt; [1] \"bobdylan/ti_some_method\" #\u0026gt; #\u0026gt; $url #\u0026gt; [1] \"https://github.com/bobdylan/ti_some_method\" #\u0026gt;   Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/def_manuscript/",
	"title": "Meta information on the manuscript",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R def_manuscript.Rd  Meta information on the manuscript\n def_manuscript(doi = NULL, google_scholar_cluster_id = NULL, preprint_date = NULL, publication_date = NULL) Arguments   doi A doi identifier (not an url)\n   google_scholar_cluster_id The google cluster id. Finding this id is a bit tricky; you need to find the manuscript on one of the author pages, and hover over the 'All X versions' button. Example: google scholar page, screenshot.\n   preprint_date Date of publication of the preprint (format: YYYY-MM-DD).\n   publication_date Date of publication of the peer-reviewed manuscript (format: YYYY-MM-DD).\n   Examples def_manuscript( doi = \"101010101/1101010101\", google_scholar_cluster_id = \"1010001010101111211\", preprint_date = \"1970-01-30\", publication_date = \"1970-01-31\" )#\u0026gt; $doi #\u0026gt; [1] \"101010101/1101010101\" #\u0026gt; #\u0026gt; $google_scholar_cluster_id #\u0026gt; [1] \"1010001010101111211\" #\u0026gt; #\u0026gt; $preprint_date #\u0026gt; [1] \"1970-01-30\" #\u0026gt; #\u0026gt; $publication_date #\u0026gt; [1] \"1970-01-31\" #\u0026gt;   Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/def_parameters/",
	"title": "Meta information on the parameters of the TI method",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R def_parameters.Rd  Parameters can be defined using dynparam::dynparam().\n def_parameters(..., parameters = NULL, forbidden = NULL) Arguments   ... Parameters to wrap in a parameter set.\n   parameters A list of parameters to wrap in a parameter set.\n   forbidden States forbidden region of parameter via a character vector, which will be turned into an expression.\n   Examples library(dynparam) def_parameters( character_parameter(id = \"method\", default = \"one\", values = c(\"one\", \"two\", \"three\")), integer_parameter( id = \"ndim\", default = 3L, distribution = uniform_distribution(lower = 2L, upper = 20L) ), numeric_parameter( id = \"beta\", default = 0.005, distribution = expuniform_distribution(lower = 1e-10, upper = 1) ) )#\u0026gt; method | type=character | domain={one, two, three} | default=one #\u0026gt; ndim | type=integer | domain=U(2, 20) | default=3 #\u0026gt; beta | type=numeric | domain=e^U(-23.03, 0.00) | default=0.005  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/def_wrapper/",
	"title": "Meta information on the wrapper",
	"tags": [],
	"description": "",
	"content": " Source: R/method_process_definition.R def_wrapper.Rd  Meta information on the wrapper\n def_wrapper(input_required, input_optional = character(), type = \"trajectory\", topology_inference = NULL, trajectory_types = character()) Arguments   input_required The required inputs for this method. See dynwrap::allowed_inputs().\n   input_optional Optional inputs for this method. See dynwrap::allowed_inputs().\n   type Which type of trajectory post-processing is used. Possible values: \"trajectory\" (default), \"linear_trajectory\", \"cyclic_trajectory\", \"branch_trajectory\", \"cluster_graph\", \"dimred_projection\", \"end_state_probabilities\", \"cell_graph\".\n   topology_inference Whether the topology is fixed (\"fixed\"), free (\"free\"), or fixed by a parameter provided to the algorithm (\"param\").\n   trajectory_types The possible trajectory types this method can return. Must be a subset of c(\"cyclic\", \"linear\", \"bifurcation\", \"convergence\", \"multifurcation\", \"tree\", \"graph\", \"acyclic_graph\", \"disconnected_graph\")\n   Examples def_wrapper( input_required = c(\"expression\", \"start_id\"), input_optional = \"groups_n\", type = \"dimred_projection\", trajectory_types = c(\"linear\", \"cyclic\"), topology_inference = \"free\" )#\u0026gt; $input_required #\u0026gt; [1] \"expression\" \"start_id\" #\u0026gt; #\u0026gt; $input_optional #\u0026gt; [1] \"groups_n\" #\u0026gt; #\u0026gt; $type #\u0026gt; [1] \"dimred_projection\" #\u0026gt; #\u0026gt; $topology_inference #\u0026gt; [1] \"free\" #\u0026gt; #\u0026gt; $trajectory_types #\u0026gt; [1] \"linear\" \"cyclic\" #\u0026gt;   Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dyneval/metric/metrics/",
	"title": "Metadata on metrics",
	"tags": [],
	"description": "",
	"content": " metrics.Rd  Also contained are:\n Ways of rendering the metrics\n Categorisation of the metrics\n The perfect and worst possible scores (if possible to determine beforehand)\n Whether the metric is symmetric (i.e. whether flipping the order of trajectories would change the expected value of the metric)\n   metrics Format An object of class tbl_df (inherits from tbl, data.frame) with 19 rows and 10 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/prior_usages/",
	"title": "Metadata on prior usages",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R prior_usages.Rd  Metadata on prior usages\n prior_usages Format An object of class tbl_df (inherits from tbl, data.frame) with 3 rows and 2 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/priors/",
	"title": "Metadata on priors",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R priors.Rd  Metadata on priors\n priors Format An object of class tbl_df (inherits from tbl, data.frame) with 11 rows and 4 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynmethods/other/methods/",
	"title": "Metadata on the different TI methods",
	"tags": [],
	"description": "",
	"content": " methods.Rd  Metadata on the different TI methods\n methods Format An object of class tbl_df (inherits from tbl, data.frame) with 59 rows and 22 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/trajectory_types/",
	"title": "Metadata on the trajectory types",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R trajectory_types.Rd  Metadata on the trajectory types\n trajectory_types Format An object of class tbl_df (inherits from tbl, data.frame) with 9 rows and 6 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynwrap/create_ti_method/wrapper_types/",
	"title": "Metadata on wrapper types",
	"tags": [],
	"description": "",
	"content": " Source: R/data.R wrapper_types.Rd  Metadata on wrapper types\n wrapper_types Format An object of class tbl_df (inherits from tbl, data.frame) with 7 rows and 4 columns.\n Contents Format  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_monocle_ddrtree/",
	"title": "Monocle DDRTree",
	"tags": [],
	"description": "",
	"content": " ti_monocle_ddrtree.Rd  Will generate a trajectory using Monocle DDRTree.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_monocle_ddrtree(reduction_method = \"ICA\", max_components = 2L, norm_method = \"log\", auto_param_selection = TRUE, filter_features = TRUE, filter_features_mean_expression = 0.1) Arguments   reduction_method A character string specifying the algorithm to use for dimensionality reduction. Domain: ICA. Default: ICA. Format: character.\n   max_components The dimensionality of the reduced space. Domain: U(2, 20). Default: 2. Format: integer.\n   norm_method Determines how to transform expression values prior to reducing dimensionality. Domain: vstExprs, log, none. Default: log. Format: character.\n   auto_param_selection When this argument is set to TRUE (default), it will automatically calculate the proper value for the ncenter (number of centroids) parameters which will be passed into DDRTree call. Default: TRUE. Format: logical.\n   filter_features Whether to include monocle feature filtering. Default: TRUE. Format: logical.\n   filter_features_mean_expression Minimal mean feature expression, only used when filter_features is set to TRUE. Domain: U(0, 10). Default: 0.1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Qiu, X., Mao, Q., Tang, Y., Wang, L., Chawla, R., Pliner, H.A., Trapnell, C., 2017. Reversed graph embedding resolves complex single-cell trajectories. Nature Methods 14, 979–982.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_monocle_ica/",
	"title": "Monocle ICA",
	"tags": [],
	"description": "",
	"content": " ti_monocle_ica.Rd  Will generate a trajectory using Monocle ICA.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_monocle_ica(reduction_method = \"ICA\", max_components = 2L, norm_method = \"log\", filter_features = TRUE, filter_features_mean_expression = 0.1) Arguments   reduction_method A character string specifying the algorithm to use for dimensionality reduction. Domain: ICA. Default: ICA. Format: character.\n   max_components The dimensionality of the reduced space. Domain: U(2, 20). Default: 2. Format: integer.\n   norm_method Determines how to transform expression values prior to reducing dimensionality. Domain: vstExprs, log, none. Default: log. Format: character.\n   filter_features Whether to include monocle feature filtering. Default: TRUE. Format: logical.\n   filter_features_mean_expression Minimal mean feature expression, only used when filter_features is set to TRUE. Domain: U(0, 10). Default: 0.1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Qiu, X., Mao, Q., Tang, Y., Wang, L., Chawla, R., Pliner, H.A., Trapnell, C., 2017. Reversed graph embedding resolves complex single-cell trajectories. Nature Methods 14, 979–982.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_mpath/",
	"title": "Mpath",
	"tags": [],
	"description": "",
	"content": " ti_mpath.Rd  Will generate a trajectory using Mpath.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_mpath(distMethod = \"euclidean\", method = \"kmeans\", numcluster = 11L, numcluster_null = TRUE, diversity_cut = 0.6, size_cut = 0.05) Arguments   distMethod The method for calculating dissimilarity between cells. distMethod can be one of \"pearson\", \"kendall\", \"spearman\" or \"euclidean\". Default is \"euclidean\". Domain: pearson, kendall, spearman, euclidean. Default: euclidean. Format: character.\n   method Method for distinguishing landmark clusters from non-landmark clusters.method can be \"kmeans\" or \"diversity\" or \"size\" or \"diversity_size\". When method=\"diversity\", numlm needs to be specified. Default is \"diversity_size\". Domain: kmeans, diversity, size, diversity_size. Default: kmeans. Format: character.\n   numcluster Number of initial clusters. Domain: U(3, 30). Default: 11. Format: integer.\n   numcluster_null If TRUE, will automatically select the number of clusters. Default: TRUE. Format: logical.\n   diversity_cut The cutoff value of diversity for differentiating landmark clusters from non-landmark clusters. The diversity of a landmark cluster must be below this cutoff. Domain: U(0.1, 1). Default: 0.6. Format: numeric.\n   size_cut The cutoff value of size i.e. number of cells for differentiating landmark clusters from non-landmark clusters. The number of cells in a landmark cluster must be greater than this cutoff. Domain: U(0.01, 1). Default: 0.05. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Chen, J., Schlitzer, A., Chakarov, S., Ginhoux, F., Poidinger, M., 2016. Mpath maps multi-branching single-cell trajectories revealing progenitor cell progression during development. Nature Communications 7.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynwrap/create_trajectory/add_end_state_probabilities/",
	"title": "Multifurcating trajectory with end state probabilities",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_end_state_probabilities.R add_end_state_probabilities.Rd  Constructs a multifurcating trajectory using the pseudotime values of each cell and their end state probabilities. If pseudotime values are not given, will use pseudotime already present in the dataset.\n add_end_state_probabilities(dataset, end_state_probabilities, pseudotime = NULL, do_scale_minmax = TRUE, ...) Arguments   dataset A dataset created by wrap_data() or wrap_expression()\n   end_state_probabilities A dataframe containing cell_id (character) and additional numeric columns containing the probability for every end milestone. If the data_frame contains only a cell_id column, the data will be processed using add_linear_trajectory\n   pseudotime A named vector of pseudo times.\n   do_scale_minmax Whether or not to scale the pseudotime between 0 and 1. Otherwise, will assume the values are already within that range.\n   ... Extras to be added to the trajectory\n   Value The trajectory\nDetails This function will generate the milestone_network and progressions.\n Contents Arguments Value Details  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_paga/",
	"title": "PAGA",
	"tags": [],
	"description": "",
	"content": " ti_paga.Rd  Will generate a trajectory using PAGA.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_paga(n_neighbors = 15L, n_comps = 50L, n_dcs = 15L, resolution = 1L, embedding_type = \"fa\", connectivity_cutoff = 0.05) Arguments   n_neighbors Number of neighbours for knn. Domain: U(1, 100). Default: 15. Format: integer.\n   n_comps Number of principal components. Domain: U(0, 100). Default: 50. Format: integer.\n   n_dcs Number of diffusion components for denoising graph, 0 means no denoising. Domain: U(0, 40). Default: 15. Format: integer.\n   resolution Resolution of louvain clustering, which determines the granularity of the clustering. Higher values will result in more clusters. Domain: U(0.1, 10). Default: 1. Format: numeric.\n   embedding_type Either 'umap' (scales very well, recommended for very large datasets) or 'fa' (ForceAtlas2, often a bit more intuitive for small datasets). Domain: umap, fa. Default: fa. Format: character.\n   connectivity_cutoff Cutoff for the connectivity matrix. Domain: U(0, 1). Default: 0.05. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Wolf, F.A., Hamey, F., Plass, M., Solana, J., Dahlin, J.S., Gottgens, B., Rajewsky, N., Simon, L., Theis, F.J., 2017. Graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_paga_tree/",
	"title": "PAGA Tree",
	"tags": [],
	"description": "",
	"content": " ti_paga_tree.Rd  Will generate a trajectory using PAGA Tree.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_paga_tree(n_neighbors = 15L, n_comps = 50L, n_dcs = 15L, resolution = 1L, embedding_type = \"fa\") Arguments   n_neighbors Number of neighbours for knn. Domain: U(1, 100). Default: 15. Format: integer.\n   n_comps Number of principal components. Domain: U(0, 100). Default: 50. Format: integer.\n   n_dcs Number of diffusion components for denoising graph, 0 means no denoising. Domain: U(0, 40). Default: 15. Format: integer.\n   resolution Resolution of louvain clustering, which determines the granularity of the clustering. Higher values will result in more clusters. Domain: U(0.1, 10). Default: 1. Format: numeric.\n   embedding_type Either 'umap' (scales very well, recommended for very large datasets) or 'fa' (ForceAtlas2, often a bit more intuitive for small datasets). Domain: umap, fa. Default: fa. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Wolf, F.A., Hamey, F., Plass, M., Solana, J., Dahlin, J.S., Gottgens, B., Rajewsky, N., Simon, L., Theis, F.J., 2017. Graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_periodpc/",
	"title": "Periodic PrinCurve",
	"tags": [],
	"description": "",
	"content": " ti_periodpc.Rd  Will generate a trajectory using Periodic PrinCurve.\nThis method was wrapped inside a container.\n ti_periodpc(ndim = 3L, maxit = 10L) Arguments   ndim . Domain: U(2, 10). Default: 3. Format: integer.\n   maxit . Domain: U(0, 100). Default: 10. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_phenopath/",
	"title": "PhenoPath",
	"tags": [],
	"description": "",
	"content": " ti_phenopath.Rd  Will generate a trajectory using PhenoPath.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_phenopath(thin = 40L, z_init = \"1\", model_mu = FALSE, scale_y = TRUE) Arguments   thin The number of iterations to wait each time before re-calculating the elbo. Domain: U(2, 500). Default: 40. Format: integer.\n   z_init The initialisation of the latent trajectory. Should be one of* A positive integer describing which principal component of the data should be used for initialisation (default 1), or * The text character \"random\", for random initialisation from a standard normal distribution. Domain: 1, 2, 3, 4, 5, random. Default: 1. Format: character.\n   model_mu Logical - should a gene-specific intercept term be modelled?. Default: FALSE. Format: logical.\n   scale_y Logical - should the expression matrix be centre scaled?. Default: TRUE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Campbell, K., Yau, C., 2017. Uncovering genomic trajectories with heterogeneous genetic and environmental backgrounds across single-cells and populations.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynplot/plot_trajectory/plot_graph/",
	"title": "Plot a trajectory and cellular positions as a graph",
	"tags": [],
	"description": "",
	"content": " plot_graph.Rd  Plot a trajectory and cellular positions as a graph\n plot_graph(traj, color_cells = c(\"auto\", \"none\", \"grouping\", \"feature\", \"milestone\", \"pseudotime\"), color_milestones = c(\"auto\", \"given\", \"cubeHelix\", \"Set3\", \"rainbow\"), grouping = NULL, groups = NULL, feature_oi = NULL, pseudotime = NULL, expression_source = \"expression\", milestones = NULL, milestone_percentages = NULL, transition_size = 3, milestone_size = 5, arrow_length = grid::unit(1, \"cm\"), label_milestones = dynwrap::is_wrapper_with_milestone_labelling(traj), plot_milestones = FALSE, adjust_weights = FALSE) Arguments   traj The trajectory\n   color_cells How to color the cells\n   color_milestones How to color the cells\n   grouping The grouping of the cells\n   groups Tibble containing information of the cell groups\n   feature_oi feature to plot expression\n   pseudotime The pseudotime\n   expression_source Source of the feature expression, defaults to `expression`\n   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   milestone_percentages The milestone percentages\n   transition_size The size of the transition lines between milestones.\n   milestone_size The size of milestones.\n   arrow_length length of the arrow.\n   label_milestones How to label the milestones. Can be TRUE (in which case the labels within the trajectory will be used), \"all\" (in which case both given labels and milestone_ids will be used), a named character vector, or FALSE\n   plot_milestones Whether to plot the milestones.\n   adjust_weights Whether or not to rescale the milestone network weights\n   Examples data(example_disconnected) plot_graph(example_disconnected)#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from trajplot_graph(example_disconnected, color_cells = \"pseudotime\")#\u0026gt; Pseudotime not provided, will calculate pseudotime from root milestone#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'T1_M4' as rootplot_graph( example_disconnected, color_cells = \"grouping\", grouping = dynwrap::group_onto_nearest_milestones(example_disconnected) )data(example_tree) plot_graph(example_tree)#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from traj  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynplot/plot_trajectory/plot_dendro/",
	"title": "Plot a trajectory as a dendrogram",
	"tags": [],
	"description": "",
	"content": " plot_dendro.Rd  Plot a trajectory as a dendrogram\n plot_dendro(traj, color_cells = c(\"auto\", \"none\", \"grouping\", \"feature\", \"milestone\", \"pseudotime\"), grouping = NULL, groups = NULL, feature_oi = NULL, expression_source = \"expression\", pseudotime = NULL, color_milestones = c(\"auto\", \"given\", \"cubeHelix\", \"Set3\", \"rainbow\"), milestones = NULL, milestone_percentages = NULL, diag_offset = 0.05, y_offset = 0.2) Arguments   traj The trajectory\n   color_cells How to color the cells\n   grouping The grouping of the cells\n   groups Tibble containing information of the cell groups\n   feature_oi feature to plot expression\n   expression_source Source of the feature expression, defaults to `expression`\n   pseudotime The pseudotime\n   color_milestones How to color the cells\n   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   milestone_percentages The milestone percentages\n   diag_offset The x-offset (percentage of the edge lenghts) between milestones\n   y_offset The size of the quasirandom cell spreading in the y-axis\n   Examples data(example_tree) plot_dendro(example_tree)#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from trajplot_dendro(example_tree, color_cells = \"pseudotime\")#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root#\u0026gt; Pseudotime not provided, will calculate pseudotime from root milestoneplot_dendro( example_tree, color_cells = \"grouping\", grouping = dynwrap::group_onto_nearest_milestones(example_tree) )#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynplot/plot_trajectory/plot_dimred/",
	"title": "Plot a trajectory on dimensionality reduction",
	"tags": [],
	"description": "",
	"content": " plot_dimred.Rd  Plot a trajectory on dimensionality reduction\n plot_dimred(traj, color_cells = c(\"auto\", \"none\", \"grouping\", \"feature\", \"milestone\", \"pseudotime\"), dimred = ifelse(dynwrap::is_wrapper_with_dimred(traj), NA, ifelse(length(traj$cell_ids) \u0026gt; 500, dimred_pca, dimred_mds)), plot_trajectory = dynwrap::is_wrapper_with_trajectory(traj) \u0026amp;\u0026amp; !plot_milestone_network, plot_milestone_network = FALSE, label_milestones = dynwrap::is_wrapper_with_milestone_labelling(traj), alpha_cells = 1, size_trajectory = 1, grouping = NULL, groups = NULL, feature_oi = NULL, color_milestones = c(\"auto\", \"given\", \"cubeHelix\", \"Set3\", \"rainbow\"), milestones = NULL, milestone_percentages = NULL, pseudotime = NULL, expression_source = \"expression\", color_density = c(\"none\", \"grouping\", \"feature\"), padding = 0.1, nbins = 1000, bw = 0.2, density_cutoff = 0.3, density_cutoff_label = density_cutoff/10, waypoints = dynwrap::select_waypoints(traj), trajectory_projection_sd = sum(traj$milestone_network$length) * 0.05, color_trajectory = \"none\") Arguments   traj The trajectory\n   color_cells How to color the cells\n   dimred The dimensionality reduction matrix (with cell_ids as rownames) or function which will run the dimensionality reduction\n   plot_trajectory Whether to plot the projected trajectory on the dimensionality reduction\n   plot_milestone_network Whether to plot the projected milestone network on the dimensionality reduction\n   label_milestones How to label the milestones. Can be TRUE (in which case the labels within the trajectory will be used), \"all\" (in which case both given labels and milestone_ids will be used), a named character vector, or FALSE\n   alpha_cells The alpha of the cells\n   size_trajectory The size of the trajectory segments\n   grouping The grouping of the cells\n   groups Tibble containing information of the cell groups\n   feature_oi feature to plot expression\n   color_milestones How to color the cells\n   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   milestone_percentages The milestone percentages\n   pseudotime The pseudotime\n   expression_source Source of the expression\n   color_density How to color density, can be \"none\", \"grouping\", or \"feature\"\n   padding The padding in the edges to the plot, relative to the size of the plot\n   nbins Number of bins for calculating the density\n   bw Bandwidth, relative to the size of the plot\n   density_cutoff Cutoff for density, the lower the larger the areas\n   density_cutoff_label Cutoff for density for labelling, the lower the further way from cells\n   waypoints The waypoints to use for projecting, as generated by [dynwrap::select_waypoints()]\n   trajectory_projection_sd The standard deviation of the gaussian kernel to be used for projecting the trajectory. This is in the order of maginature as the lengths of the milestone_network. The lower, the more closely the trajectory will follow the cells\n   color_trajectory How to color the trajectory, can be \"nearest\" for coloring to nearest cell, or \"none\"\n   Examples data(example_bifurcating) plot_dimred(example_bifurcating)#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from trajplot_dimred(example_bifurcating, dimred = dyndimred::dimred_umap)#\u0026gt; Loading required namespace: uwot#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from trajdimred \u0026lt;- dyndimred::dimred_dm_destiny(example_bifurcating$expression)#\u0026gt; Loading required namespace: destinyplot_dimred(example_bifurcating, dimred = dimred)#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from trajplot_dimred(example_bifurcating, color_cells = \"pseudotime\")#\u0026gt; Pseudotime not provided, will calculate pseudotime from root milestone#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as rootplot_dimred( example_bifurcating, color_density = \"grouping\", grouping = dynwrap::group_onto_nearest_milestones(example_bifurcating) )#\u0026gt; Coloring by grouping  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynplot/other/dynplot/",
	"title": "Plot all the trajectories",
	"tags": [],
	"description": "",
	"content": " dynplot.Rd  Plot all the trajectories\n  Contents  -- "
},
{
	"uri": "/reference/dynplot/plot_trajectory/plot_onedim/",
	"title": "Plot onedim",
	"tags": [],
	"description": "",
	"content": " plot_onedim.Rd  Plot onedim\n plot_onedim(traj, color_cells = c(\"auto\", \"none\", \"grouping\", \"feature\", \"milestone\", \"pseudotime\"), grouping = NULL, groups = NULL, feature_oi = NULL, pseudotime = NULL, expression_source = \"expression\", color_milestones = c(\"auto\", \"given\", \"cubeHelix\", \"Set3\", \"rainbow\"), milestones = NULL, milestone_percentages = NULL, orientation = 1, margin = 0.05, linearised = linearise_cells(traj, margin, one_edge = TRUE), quasirandom_width = 0.2, plot_cells = TRUE, label_milestones = dynwrap::is_wrapper_with_milestone_labelling(traj)) Arguments   traj The trajectory\n   color_cells How to color the cells\n   grouping The grouping of the cells\n   groups Tibble containing information of the cell groups\n   feature_oi feature to plot expression\n   pseudotime The pseudotime\n   expression_source Source of the feature expression, defaults to `expression`\n   color_milestones How to color the cells\n   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   milestone_percentages The milestone percentages\n   orientation Whether to plot the connections in the top (1) or bottom (-1)\n   margin The margin to add\n   linearised The linearised milestone network and progressions\n   quasirandom_width The width of the quasirandom cell spreading\n   plot_cells Whether to plot the cells\n   label_milestones How to label the milestones. Can be TRUE (in which case the labels within the trajectory will be used), \"all\" (in which case both given labels and milestone_ids will be used), a named character vector, or FALSE\n   Examples data(example_linear) plot_onedim(example_linear)#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from trajplot_onedim(example_linear, label_milestones = TRUE)#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from trajdata(example_tree) plot_onedim(example_tree)#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root#\u0026gt; Coloring by milestone#\u0026gt; Using milestone_percentages from traj  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynplot/compare_trajectory/plot_strip/",
	"title": "Plot strip",
	"tags": [],
	"description": "",
	"content": " plot_strip.Rd  Plot strip\n plot_strip(traj1, traj2, margin = 0.05, reorder = TRUE) Arguments   traj1 The first trajectory\n   traj2 The second traj\n   margin The margin to add\n   reorder Whether to reorder\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/compare_trajectory/plot_linearised_comparison/",
	"title": "Plot strip onedim",
	"tags": [],
	"description": "",
	"content": " plot_linearised_comparison.Rd  Plot strip onedim\n plot_linearised_comparison(traj1, traj2, reorder = TRUE, margin = 0.05, reorder_second_by = c(\"mapping\", \"optimisation\")) Arguments   traj1 The first trajectory\n   traj2 The second trajectory\n   reorder Whether to reorder the trajectory\n   margin The margin to add\n   reorder_second_by How to reorder the second trajectory, either by mapping the milestones from both trajectories (`mapping`), or by trying to correlate the orderings between the two trajectories (`optimisation`)\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/plot_trajectory/plot_heatmap/",
	"title": "Plot the expression across a trajectory in a heatmap",
	"tags": [],
	"description": "",
	"content": " plot_heatmap.Rd  When using RStudio: the heatmap will not show inside the plot area, but will be visible once you click the zoom button.\n plot_heatmap(traj, expression_source = \"expression\", features_oi = 20, clust = \"ward.D2\", margin = 0.02, color_cells = NULL, milestones = NULL, milestone_percentages = traj$milestone_percentages, grouping = NULL, groups = NULL, cell_feature_importances = NULL, heatmap_type = c(\"tiled\", \"dotted\"), scale = dynutils::scale_quantile, label_milestones = TRUE) Arguments   traj The trajectory\n   expression_source Source of the feature expression, defaults to `expression`\n   features_oi The features of interest, either the number of features or a vector giving the names of the different features\n   clust The method to cluster the features, or a hclust object\n   margin The margin to add\n   color_cells How to color the cells\n   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   milestone_percentages The milestone percentages\n   grouping The grouping of the cells\n   groups Tibble containing information of the cell groups\n   cell_feature_importances The importances of every feature in every cell, as returned by [dynfeature::calculate_cell_feature_importance()]\n   heatmap_type The type of heatmap, either tiled or dotted\n   scale Whether to rescale the expression, can be a function or boolean\n   label_milestones How to label the milestones. Can be TRUE (in which case the labels within the trajectory will be used), \"all\" (in which case both given labels and milestone_ids will be used), a named character vector, or FALSE\n   Examples data(example_linear) plot_heatmap(example_linear)#\u0026gt; No features of interest provided, selecting the top 20 features automatically#\u0026gt; Using dynfeature for selecting the top 20 features#\u0026gt; Loading required namespace: dynfeature#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root#\u0026gt; Coloring by milestonedata(example_bifurcating) plot_heatmap(example_bifurcating)#\u0026gt; No features of interest provided, selecting the top 20 features automatically#\u0026gt; Using dynfeature for selecting the top 20 features#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root#\u0026gt; Coloring by milestone  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynplot/plot_trajectory/plot_topology/",
	"title": "Plot the topology of a trajectory",
	"tags": [],
	"description": "",
	"content": " plot_topology.Rd  Plot the topology of a trajectory\n plot_topology(traj, color_milestones = c(\"auto\", \"given\", \"cubeHelix\", \"Set3\", \"rainbow\"), milestones = NULL, layout = NULL) Arguments   traj The trajectory\n   color_milestones How to color the cells\n   milestones Tibble containing the `milestone_id` and a `color` for each milestone\n   layout The type of layout to create.\n   Examples data(example_disconnected) plot_topology(example_disconnected)#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'T1_M4' as rootdata(example_tree) plot_topology(example_tree)#\u0026gt; root cell or milestone not provided, trying first outgoing milestone_id#\u0026gt; Using 'M1' as root  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynplot/compare_trajectory/plot_edge_flips/",
	"title": "Plotting edge flips",
	"tags": [],
	"description": "",
	"content": " plot_edge_flips.Rd  Utility plotting function for analysing the edge-flip metric from dyneval.\n plot_edge_flips(oldadj, newadj) Arguments   oldadj Old adjacency matrix\n   newadj New adjancency matrix\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynplot/other/project_waypoints/",
	"title": "Project the waypoints",
	"tags": [],
	"description": "",
	"content": " project_waypoints.Rd  Project the waypoints\n project_waypoints(traj, cell_positions, waypoints = dynwrap::select_waypoints(traj), trajectory_projection_sd = sum(traj$milestone_network$length) * 0.05, color_trajectory = \"none\") Arguments   traj The trajectory\n   cell_positions The positions of the cells\n   waypoints The waypoints to use for projecting, as generated by [dynwrap::select_waypoints()]\n   trajectory_projection_sd The standard deviation of the gaussian kernel\n   color_trajectory How to color the trajectory, can be \"nearest\" for coloring to nearest cell, or \"none\"\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_projected_dpt/",
	"title": "Projected DPT",
	"tags": [],
	"description": "",
	"content": " ti_projected_dpt.Rd  Will generate a trajectory using Projected DPT.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_projected_dpt(sigma = \"local\", distance = \"euclidean\", ndim = 20L, density_norm = TRUE, n_local = c(5L, 7L), w_width = 0.1) Arguments   sigma Diffusion scale parameter of the Gaussian kernel. A larger sigma might be necessary if the eigenvalues can not be found because of a singularity in the matrix. Must a character vector -- \"local\" (default) or \"global\". Domain: local, global. Default: local. Format: character.\n   distance A character vector specifying which distance metric to use. Allowed measures are the Euclidean distance (default), the cosine distance (1-corr(c_1, c_2)), or the rank correlation distance (1-corr(rank(c_1), rank(c_2))). Domain: euclidean, cosine, rankcor. Default: euclidean. Format: character.\n   ndim Number of eigenvectors/dimensions to return. Domain: U(3, 100). Default: 20. Format: integer.\n   density_norm Logical. If TRUE, use density normalisation. Default: TRUE. Format: logical.\n   n_local If sigma == 'local', the n_local nearest neighbor(s) determine(s) the local sigma. Domain: ( U(2, 20), U(2, 20) ). Default: (5, 7). Format: integer_range.\n   w_width Window width to use for deciding the branch cutoff. Domain: e^U(-9.21, 0.00). Default: 0.1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_projected_monocle/",
	"title": "Projected Monocle",
	"tags": [],
	"description": "",
	"content": " ti_projected_monocle.Rd  Will generate a trajectory using Projected Monocle.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_projected_monocle(reduction_method = \"DDRTree\", max_components = 2L, norm_method = \"vstExprs\", auto_param_selection = TRUE, filter_features = TRUE, filter_features_mean_expression = 0.1) Arguments   reduction_method A character string specifying the algorithm to use for dimensionality reduction. Domain: DDRTree. Default: DDRTree. Format: character.\n   max_components The dimensionality of the reduced space. Domain: U(2, 20). Default: 2. Format: integer.\n   norm_method Determines how to transform expression values prior to reducing dimensionality. Domain: vstExprs, log, none. Default: vstExprs. Format: character.\n   auto_param_selection When this argument is set to TRUE (default), it will automatically calculate the proper value for the ncenter (number of centroids) parameters which will be passed into DDRTree call. Default: TRUE. Format: logical.\n   filter_features Whether to include monocle feature filtering. Default: TRUE. Format: logical.\n   filter_features_mean_expression Minimal mean feature expression, only used when filter_features is set to TRUE. Domain: U(0, 10). Default: 0.1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_projected_paga/",
	"title": "Projected PAGA",
	"tags": [],
	"description": "",
	"content": " ti_projected_paga.Rd  Will generate a trajectory using Projected PAGA.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_projected_paga(n_neighbors = 15L, n_comps = 50L, n_dcs = 15L, resolution = 1L, embedding_type = \"fa\", connectivity_cutoff = 0.05) Arguments   n_neighbors Number of neighbours for knn. Domain: U(1, 100). Default: 15. Format: integer.\n   n_comps Number of principal components. Domain: U(0, 100). Default: 50. Format: integer.\n   n_dcs Number of diffusion components for denoising graph, 0 means no denoising. Domain: U(0, 40). Default: 15. Format: integer.\n   resolution Resolution of louvain clustering, which determines the granularity of the clustering. Higher values will result in more clusters. Domain: U(0.1, 10). Default: 1. Format: numeric.\n   embedding_type Either 'umap' (scales very well, recommended for very large datasets) or 'fa' (ForceAtlas2, often a bit more intuitive for small datasets). Domain: umap, fa. Default: fa. Format: character.\n   connectivity_cutoff Cutoff for the connectivity matrix. Domain: U(0, 1). Default: 0.05. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Wolf, F.A., Hamey, F., Plass, M., Solana, J., Dahlin, J.S., Gottgens, B., Rajewsky, N., Simon, L., Theis, F.J., 2017. Graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_projected_slingshot/",
	"title": "Projected Slingshot",
	"tags": [],
	"description": "",
	"content": " ti_projected_slingshot.Rd  Will generate a trajectory using Projected Slingshot.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_projected_slingshot(shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2, smoother = \"smooth.spline\", shrink.method = \"cosine\") Arguments   shrink Logical or numeric between 0 and 1, determines whether and how much to shrink branching lineages toward their average prior to the split. Domain: e^U(-Inf, 0.00). Default: 1. Format: numeric.\n   reweight Logical, whether to allow cells shared between lineages to be reweighted during curve-fitting. If TRUE, cells shared between lineages will be weighted by: distance to nearest curve / distance to curve. Default: TRUE. Format: logical.\n   reassign Logical, whether to reassign cells to lineages at each iteration. If TRUE, cells will be added to a lineage when their projection distance to the curve is less than the median distance for all cells currently assigned to the lineage. Additionally, shared cells will be removed from a lineage if their projection distance to the curve is above the 90th percentile and their weight along the curve is less than 0.1. Default: TRUE. Format: logical.\n   thresh Numeric, determines the convergence criterion. Percent change in the total distance from cells to their projections along curves must be less than thresh. Default is 0.001, similar to principal.curve. Domain: e^U(-11.51, 11.51). Default: 0.001. Format: numeric.\n   maxit Numeric, maximum number of iterations, see principal.curve. Domain: U(0, 50). Default: 10. Format: integer.\n   stretch Numeric factor by which curves can be extrapolated beyond endpoints. Default is 2, see principal.curve. Domain: e^U(-Inf, 1.61). Default: 2. Format: numeric.\n   smoother Choice of scatter plot smoother. Same as principal.curve, but \"lowess\" option is replaced with \"loess\" for additional flexibility. Domain: smooth.spline, loess, periodic.lowess. Default: smooth.spline. Format: character.\n   shrink.method Character denoting how to determine the appropriate amount of shrinkage for a branching lineage. Accepted values are the same as for kernel in density() (default is \"cosine\"), as well as \"tricube\" and \"density\". See 'Details' for more. Domain: cosine, tricube, density. Default: cosine. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Street, K., Risso, D., Fletcher, R.B., Das, D., Ngai, J., Yosef, N., Purdom, E., Dudoit, S., 2018. Slingshot: cell lineage and pseudotime inference for single-cell transcriptomics. BMC Genomics 19.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_projected_tscan/",
	"title": "Projected TSCAN",
	"tags": [],
	"description": "",
	"content": " ti_projected_tscan.Rd  Will generate a trajectory using Projected TSCAN.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_projected_tscan(minexpr_percent = 0L, minexpr_value = 0L, cvcutoff = 0L, clusternum = c(2L, 9L), modelNames = \"VVV\") Arguments   minexpr_percent . Domain: U(0, 1). Default: 0. Format: numeric.\n   minexpr_value . Domain: U(0, 10). Default: 0. Format: numeric.\n   cvcutoff . Domain: U(0, 5). Default: 0. Format: numeric.\n   clusternum . Domain: ( U(2, 20), U(2, 20) ). Default: (2, 9). Format: integer_range.\n   modelNames . Domain: EII, VII, EEI, VEI, EVI, VVI, EEE, EVE, VEE, VVE, EEV, VEV, EVV, VVV. Default: VVV. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_raceid_stemid/",
	"title": "RaceID / StemID",
	"tags": [],
	"description": "",
	"content": " ti_raceid_stemid.Rd  Will generate a trajectory using RaceID / StemID.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_raceid_stemid(knn = 10L, ccor = 0.4, metric = \"pearson\", sat = TRUE, samp = 1000L, cln = 30L, clustnr = 30L, bootnr = 50L, FUNcluster = \"kmedoids\", probthr = 0.001, outminc = 5L, outlg = 2L, outdistquant = 0.95, initial_cmd = TRUE, perplexity = 30L, cthr = 5L, nmode = TRUE, projcells_knn = 3L, fr = FALSE, pdishuf = 500L, fast = FALSE, pthr = 0.01, scthr = 0.2) Arguments   knn Number of nearest neighbors used to infer corresponding cell types in different batches. Domain: U(5, 50). Default: 10. Format: integer.\n   ccor Correlation coefficient used as a treshhold for determining genes correlated to eachother. Domain: U(0, 1). Default: 0.4. Format: numeric.\n   metric Distances are computed from the filtered expression matrix after optional feature selection, dimensional reduction, and/or transformation (batch correction). Domain: pearson, spearman, logpearson, euclidean. Default: pearson. Format: character.\n   sat If TRUE, then the number of clusters is determined based on finding the saturation point of the mean within-cluster dispersion as a function of the cluster number. If FALSE, then cluster number needs to be given as cln. Default: TRUE. Format: logical.\n   samp Number of bootstrapping runs for clusterboot. Domain: e^U(3.91, 9.21). Default: 1000. Format: integer.\n   cln Number of clusters to be used. If sat is TRUE, this number is inferred by the saturation criterion. Domain: U(10, 100). Default: 30. Format: integer.\n   clustnr Maximum number of clusters for the derivation of the cluster number by the saturation of mean within-cluster-dispersion. Domain: U(10, 100). Default: 30. Format: integer.\n   bootnr Number of booststrapping runs for clusterboot. Domain: U(20, 100). Default: 50. Format: integer.\n   FUNcluster Clustering method used by RaceID3. Domain: kmedoids, kmeans, hclust. Default: kmedoids. Format: character.\n   probthr Outlier probability threshold for a minimum of outlg genes to be an outlier cell. This probability is computed from a negative binomial background model of expression in a cluster. Domain: e^U(-11.51, 0.00). Default: 0.001. Format: numeric.\n   outminc Minimal transcript count of a gene in a clusters to be tested for being an outlier gene. Domain: U(0, 100). Default: 5. Format: integer.\n   outlg Minimum number of outlier genes required for being an outlier cell. Domain: U(0, 100). Default: 2. Format: integer.\n   outdistquant Real number between zero and one. Outlier cells are merged to outlier clusters if their distance smaller than the outdistquant-quantile of the distance distribution of pairs of cells in the orginal clusters after outlier removal. Domain: U(0, 1). Default: 0.95. Format: numeric.\n   initial_cmd If TRUE, then the t-SNE map computation is initialized with a configuration obtained by classical multidimensional scaling. Default: TRUE. Format: logical.\n   perplexity Perplexity of the t-SNE map. Domain: U(5, 100). Default: 30. Format: integer.\n   cthr Clusters to be included into the StemID2 analysis must contain more than cthr cells. D. Domain: U(1, 25). Default: 5. Format: integer.\n   nmode If TRUE, then a cell of given cluster is assigned to the link to the cluster with the smallest average distance of the knn nearest neighbours within this cluster. Default: TRUE. Format: logical.\n   projcells_knn See nmode. Domain: U(3, 20). Default: 3. Format: integer.\n   fr Use Fruchterman-Rheingold layout instead of t-SNE for dimensional-reduction representation of the lineage tree. Default: FALSE. Format: logical.\n   pdishuf Number of randomizations of cell positions for which to compute projections of cells on inter-cluster links. Domain: e^U(2.30, 9.21). Default: 500. Format: integer.\n   fast If TRUE and nmode is FALSE cells will still be assigned to links based on maximum projections but a fast approximate background model will be used to infer significance. The function will do nothing in this case. Default: FALSE. Format: logical.\n   pthr P-value cutoff for link significance. This threshold is applied for the calculation of link scores reflecting how uniformly a link is occupied by cells. Domain: e^U(-11.51, 0.00). Default: 0.01. Format: numeric.\n   scthr Score threshold for links to be shown in the graph. Domain: U(0, 1). Default: 0.2. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Grün, D., Muraro, M.J., Boisset, J.-C., Wiebrands, K., Lyubimova, A., Dharmadhikari, G., van den Born, M., van Es, J., Jansen, E., Clevers, H., de Koning, E.J.P., van Oudenaarden, A., 2016. De Novo Prediction of Stem Cell Identity using Single-Cell Transcriptome Data. Cell Stem Cell 19, 266–277.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_random/",
	"title": "Random",
	"tags": [],
	"description": "",
	"content": " ti_random.Rd  Will generate a trajectory using Random.\nThis method was wrapped inside a container.\n ti_random(dummy_param = 0.5) Arguments   dummy_param Dummy parameter. Domain: U(0, 1). Default: 0.5. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynwrap/infer_trajectory/get_ti_methods/",
	"title": "Return all TI ti_methods",
	"tags": [],
	"description": "",
	"content": " Source: R/method_get_ti_methods.R get_ti_methods.Rd  Return all TI ti_methods\n get_ti_methods(method_ids = NULL, as_tibble = TRUE, ti_packages = ifelse(\"dynmethods\" %in% rownames(utils::installed.packages()), \"dynmethods\", \"dynwrap\"), evaluate = FALSE) Arguments   method_ids The method identifiers. NULL if listing all methods\n   as_tibble Whether or not to return the ti_methods as a tibble\n   ti_packages In which packages to look for ti methods\n   evaluate Automatically evaluate the functions\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/add_root/",
	"title": "Root the trajectory",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_root.R add_root.Rd  Roots the trajectory by changing the directionality of all edges given a root cell\n add_root(trajectory, root_cell_id = trajectory$root_cell_id, root_milestone_id = trajectory$root_milestone_id, flip_edges = TRUE) add_root_using_expression(trajectory, features_oi, expression_source = \"expression\") is_rooted(trajectory) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   root_cell_id The root cell id, not required if root_milestone_id is given\n   root_milestone_id The root milestone id, not required if root_cell_id is given\n   flip_edges Whether to flip edges which are going in the other direction compared to the root\n   features_oi The feature ids which will be used to root\n   expression_source Source of the expression, either a string or a matrix\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dyneval/evaluation/evaluate_ti_method/",
	"title": "Running an evaluation of a method on a set of datasets with a set of parameters",
	"tags": [],
	"description": "",
	"content": " evaluate_ti_method.Rd  Running an evaluation of a method on a set of datasets with a set of parameters\n evaluate_ti_method(dataset, method, parameters, metrics, give_priors = NULL, output_model = TRUE, seed = function() random_seed(), map_fun = map, verbose = FALSE) Arguments   dataset The first trajectory, in most cases a gold standard trajectory\n   method One or more methods. Must be one of:\n an object or list of ti_... objects (eg. dynmethods::ti_comp1()),\n a character vector containing the names of methods to execute (e.g. \"scorpius\"),\n a character vector containing dockerhub repositories (e.g. dynverse/paga), or\n a dynguidelines data frame.\n    parameters A set of parameters to be used during trajectory inference. A parameter set must be a named list of parameters. If multiple methods were provided in the method parameter, parameters must be an unnamed list of the same length.\n   metrics Which metrics to evaluate. Check dyneval::metrics for a list of possible metrics. Passing a custom metric function with format function(dataset, model) { 1 } is also supported. The name of this function within the list will be used as the name of the metric.\n   give_priors All the priors a method is allowed to receive. Must be a subset of all available priors (dynwrap::priors).\n   output_model Whether or not the model will be outputted.\n   seed A seed to be passed to the TI method.\n   map_fun A map function to use when inferring trajectories with multiple datasets or methods. Allows to parallellise the execution in an arbitrary way.\n   verbose Whether or not to print information output.\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_scimitar/",
	"title": "SCIMITAR",
	"tags": [],
	"description": "",
	"content": " ti_scimitar.Rd  Will generate a trajectory using SCIMITAR.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_scimitar(covariance_type = \"diag\", degree = 3L, step_size = 0.07, cov_estimator = \"identity\", cov_reg = 0.05, max_iter = 3L) Arguments   covariance_type . Domain: diag, spherical, full. Default: diag. Format: character.\n   degree . Domain: U(1, 20). Default: 3. Format: integer.\n   step_size . Domain: e^U(-4.61, -2.30). Default: 0.07. Format: numeric.\n   cov_estimator . Domain: identity, diag, sample, global, glasso, average. Default: identity. Format: character.\n   cov_reg . Domain: e^U(-4.61, -2.30). Default: 0.05. Format: numeric.\n   max_iter . Domain: U(1, 20). Default: 3. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences CORDERO, P., STUART, J.M., 2016. TRACING CO-REGULATORY NETWORK DYNAMICS IN NOISY, SINGLE-CELL TRANSCRIPTOME TRAJECTORIES. Biocomputing 2017.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_scorpius/",
	"title": "SCORPIUS",
	"tags": [],
	"description": "",
	"content": " ti_scorpius.Rd  Will generate a trajectory using SCORPIUS.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_scorpius(distance_method = \"spearman\", ndim = 3L, k = 4L, thresh = 0.001, maxit = 10L, stretch = 0, smoother = \"smooth_spline\", sparse = TRUE) Arguments   distance_method A character string indicating which correlationcoefficient (or covariance) is to be computed. One of \"pearson\", \"kendall\", or \"spearman\". Domain: spearman, pearson, kendall. Default: spearman. Format: character.\n   ndim The number of dimensions in the new space. Domain: U(2, 20). Default: 3. Format: integer.\n   k The number of clusters to cluster the data into. Domain: U(1, 20). Default: 4. Format: integer.\n   thresh principal_curve parameter; convergence threshhold on shortest distances to the curve. Domain: e^U(-11.51, 11.51). Default: 0.001. Format: numeric.\n   maxit principal_curve parameter; maximum number of iterations. Domain: U(0, 50). Default: 10. Format: integer.\n   stretch principal_curve parameter; a factor by which the curve can be extrapolated when points are projected. Domain: U(0, 5). Default: 0. Format: numeric.\n   smoother principal_curve parameter; choice of smoother. Domain: smooth_spline, lowess, periodic_lowess. Default: smooth_spline. Format: character.\n   sparse Whether or not to use sparse MDS dimensionality reduction, for datasets with large amounts of cells. Default: TRUE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Cannoodt, R., Saelens, W., Sichien, D., Tavernier, S., Janssens, S., Guilliams, M., Lambrecht, B.N., De Preter, K., Saeys, Y., 2016. SCORPIUS improves trajectory inference and identifies novel modules in dendritic cell development.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_scoup/",
	"title": "SCOUP",
	"tags": [],
	"description": "",
	"content": " ti_scoup.Rd  Will generate a trajectory using SCOUP.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_scoup(ndim = 2L, max_ite1 = 100L, max_ite2 = 100L, alpha = c(0.1, 100), t = c(0.001, 2), sigma_squared = 0.1, thresh = 0.01) Arguments   ndim Number of pca dimensions. Domain: U(2, 20). Default: 2. Format: integer.\n   max_ite1 Upper bound of EM iteration (without pseudo-time optimization). Domain: e^U(0.69, 8.52). Default: 100. Format: integer.\n   max_ite2 Upper bound of EM iteration (including pseudo-time optimization). Domain: e^U(0.69, 13.12). Default: 100. Format: integer.\n   alpha Bounds of alpha. Domain: ( e^U(-6.91, 2.30), e^U(-6.91, 2.30) ). Default: (0.1, 100). Format: numeric_range.\n   t Bounds of pseudo-time. Domain: ( e^U(-11.51, 0.00), e^U(-11.51, 0.00) ). Default: (0.001, 2). Format: numeric_range.\n   sigma_squared Lower bound of sigma squared. Domain: e^U(-6.91, 2.30). Default: 0.1. Format: numeric.\n   thresh Threshold. Domain: e^U(-4.61, 2.30). Default: 0.01. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Matsumoto, H., Kiryu, H., 2016. SCOUP: a probabilistic model based on the Ornstein–Uhlenbeck process to analyze single-cell expression data during differentiation. BMC Bioinformatics 17.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_scuba/",
	"title": "SCUBA",
	"tags": [],
	"description": "",
	"content": " ti_scuba.Rd  Will generate a trajectory using SCUBA.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_scuba(rigorous_gap_stats = TRUE, N_dim = 2L, low_gene_threshold = 1L, low_gene_fraction_max = 0.7, min_split = 15L, min_percentage_split = 0.25) Arguments   rigorous_gap_stats Whether to use rigorous gap statistics to determine number of clusters. Default: TRUE. Format: logical.\n   N_dim Number of TSNE dimensions. Domain: U(2, 3). Default: 2. Format: integer.\n   low_gene_threshold Threshold value for genes of low expression levels. Domain: U(0, 5). Default: 1. Format: numeric.\n   low_gene_fraction_max Maximum fraction of lowly-expressed cells allowed for each gene. Domain: U(0, 1). Default: 0.7. Format: numeric.\n   min_split Lower threshold on the number of cells in a cluster for this cluster to be split. Domain: U(1, 100). Default: 15. Format: integer.\n   min_percentage_split Minimum fraction of cells in the smaller cluster during a bifurcation. Domain: U(0, 1). Default: 0.25. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Marco, E., Karp, R.L., Guo, G., Robson, P., Hart, A.H., Trippa, L., Yuan, G.-C., 2014. Bifurcation analysis of single-cell gene expression data reveals epigenetic landscape. Proceedings of the National Academy of Sciences 111, E5643–E5650.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_slice/",
	"title": "SLICE",
	"tags": [],
	"description": "",
	"content": " ti_slice.Rd  Will generate a trajectory using SLICE.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_slice(lm.method = \"clustering\", model.type = \"tree\", ss.method = \"all\", ss.threshold = 0.25, community.method = \"louvain\", cluster.method = \"kmeans\", k = 0L, k.max = 10L, B = 100L, k.opt.method = \"firstmax\") Arguments   lm.method Select \"clustering\" based or \"graph\" based method to infer lineage model. Domain: clustering, graph. Default: clustering. Format: character.\n   model.type The type of models that will be infered: \"tree\" - directed minimum spanning tree based, \"graph\" - directed graph based. Domain: tree, graph. Default: tree. Format: character.\n   ss.method The method for defining core cell set for stable state detection: all - all the cells in a cluster constitute the core cell set; top - cells with scEntropy lower than the ss.threshold quantile of all the values in a cluster constitute the core cell set; pcst - cells with scEntropy lower than the ss.threshold quantile of all the values in a cluster constitute the prize nodes, linear prize-collecting steiner tree algorithm is used to approximate an optimal subnetwork, the cells in the subnetwork constitute the core cell set. Stable states are defined as the centroids of the core cell sets. Domain: all, top, pcst. Default: all. Format: character.\n   ss.threshold The threshold used when ss.method is \"top\" or \"pcst\". Default: 0.25. Domain: U(0, 1). Default: 0.25. Format: numeric.\n   community.method The method for network community detection. Most of the community detection methods implemented in the igraph package are supported, including \"fast_greedy\", \"edge_betweenness\", \"label_prop\", \"leading_eigen\",\"louvain\",\"spinglass\", \"walktrap\". If this parameter is set to \"auto\", the algorithm will perform all the community detection methods and select the one that generates the communities with best modularity. Only take effect when lm.method is \"graph\". Domain: fast_greedy, edge_betweenness, label_prop, leading_eigen, louvain, spinglass, walktrap, auto. Default: louvain. Format: character.\n   cluster.method Use \"kmeans\" or \"pam\" to divide cells into clusters. Only take effect when lm.method is \"clustering\". Domain: kmeans, pam. Default: kmeans. Format: character.\n   k The number of cell clusters. If NULL, Gap statistic will be used to determine an optimal k. Domain: U(0, 20). Default: 0. Format: integer.\n   k.max The \"k.max\" parameter of cluster::clusGap(); used when k is NULL. Domain: U(3, 20). Default: 10. Format: integer.\n   B The \"B\" parameter of cluster::clusGap(); used when k is NULL. Domain: U(3, 500). Default: 100. Format: integer.\n   k.opt.method The \"method\" parameter of cluster::maxSE(); used when k is NULL. Domain: firstmax, globalmax, Tibs2001SEmax, firstSEmax, globalSEmax. Default: firstmax. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Guo, M., Bao, E.L., Wagner, M., Whitsett, J.A., Xu, Y., 2016. SLICE: determining cell differentiation and lineage based on single cell entropy. Nucleic Acids Research gkw1278.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_slicer/",
	"title": "SLICER",
	"tags": [],
	"description": "",
	"content": " ti_slicer.Rd  Will generate a trajectory using SLICER.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_slicer(kmin = 10L, m = 2L) Arguments   kmin Smallest value of k to try. Domain: U(2, 20). Default: 10. Format: integer.\n   m Intrinsic dimension of the data. This parameter mainly influences the visualisation of the results. The real intrinsic dimension will be calculated automaticly. Domain: U(2, 20). Default: 2. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Welch, J.D., Hartemink, A.J., Prins, J.F., 2016. SLICER: inferring branched, nonlinear cellular trajectories from single cell RNA-seq data. Genome Biology 17.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_stemnet/",
	"title": "STEMNET",
	"tags": [],
	"description": "",
	"content": " ti_stemnet.Rd  Will generate a trajectory using STEMNET.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_stemnet(alpha = 0.1, lambda_auto = TRUE, lambda = 0.1, force = FALSE) Arguments   alpha The elastic net mixing parameter of the ‘glmnet’ classifier. Domain: e^U(-6.91, 2.30). Default: 0.1. Format: numeric.\n   lambda_auto Whether to select the lambda by cross-validation. Default: TRUE. Format: logical.\n   lambda The lambda penalty of GLM. Domain: e^U(-3.00, 0.00). Default: 0.1. Format: numeric.\n   force Do not use! This is a parameter to force STEMNET to run on benchmark datasets where not enough end groups are present. Default: FALSE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Velten, L., Haas, S.F., Raffel, S., Blaszkiewicz, S., Islam, S., Hennig, B.P., Hirche, C., Lutz, C., Buss, E.C., Nowak, D., Boch, T., Hofmann, W.-K., Ho, A.D., Huber, W., Trumpp, A., Essers, M.A.G., Steinmetz, L.M., 2017. Human haematopoietic stem cell lineage commitment is a continuous process. Nature Cell Biology 19, 271–281.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynwrap/other/select_waypoint_cells/",
	"title": "Select the waypoint cells",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_add_cell_waypoints.R select_waypoint_cells.Rd  Waypoint cells are cells spread across all of the trajectory such that there is no other cell that has a large geodesic distance to any of the waypoint cells.\n select_waypoint_cells(milestone_ids, milestone_network, milestone_percentages, progressions, divergence_regions, num_cells_selected = 100) Arguments   milestone_ids The ids of the milestones in the trajectory. Type: Character vector.\n   milestone_network The network of the milestones. Type: Data frame(from = character, to = character, length = numeric, directed = logical).\n   milestone_percentages A data frame specifying what percentage milestone each cell consists of. Type: Data frame(cell_id = character, milestone_id = character, percentage = numeric).\n   progressions Specifies the progression of a cell along a transition in the milestone_network. Type: Data frame(cell_id = character, from = character, to = character, percentage = numeric).\n   divergence_regions A data frame specifying the divergence regions between milestones (e.g. a bifurcation). Type: Data frame(divergence_id = character, milestone_id = character, is_start = logical).\n   num_cells_selected About the number of cells selected as waypoints\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynwrap/adapt_trajectory/simplify_trajectory/",
	"title": "Simplify a trajectory by removing transient milestones",
	"tags": [],
	"description": "",
	"content": " Source: R/simplify_trajectory.R simplify_trajectory.Rd  Transient milestones are milestones with a degree of two (if undirected) or with an indegree of one and outdegree of one (if directed)\n simplify_trajectory(trajectory, allow_self_loops = FALSE) Arguments   trajectory The trajectory as created by infer_trajectory() or add_trajectory()\n   allow_self_loops Whether or not to allow self loops.\n   Details The positions of the cells within the trajectory remain the same\nA -\u0026gt; B -\u0026gt; C is simplified to A -\u0026gt; C.\nA — B — C is simplified to A — C.\nA -\u0026gt; B -\u0026gt; C -\u0026gt; D -\u0026gt; A is simplified to A -\u0026gt; B -\u0026gt; D.\n Contents Arguments Details  -- "
},
{
	"uri": "/reference/dynwrap/other/simplify_igraph_network/",
	"title": "Simplify an igraph network such that consecutive linear edges are removed",
	"tags": [],
	"description": "",
	"content": " Source: R/simplify_igraph_network.R simplify_igraph_network.Rd  Simplify an igraph network such that consecutive linear edges are removed\n simplify_igraph_network(gr, allow_duplicated_edges = TRUE, allow_self_loops = TRUE, force_keep = NULL, edge_points = NULL) Arguments   gr an igraph object\n   allow_duplicated_edges Whether or not to allow duplicated edges between nodes.\n   allow_self_loops Whether or not to allow self loops.\n   force_keep Nodes that will not be removed under any condition\n   edge_points Points that are on edges\n   Examples net \u0026lt;- data.frame( from = 1:2, to = 2:3, length = 1, directed = TRUE, stringsAsFactors = F ) gr \u0026lt;- igraph::graph_from_data_frame(net) simplify_igraph_network(gr)#\u0026gt; IGRAPH 607ed04 DNW- 2 1 -- #\u0026gt; + attr: name (v/c), length (e/n), directed (e/l), weight (e/n) #\u0026gt; + edge from 607ed04 (vertex names): #\u0026gt; [1] 1-\u0026gt;3net \u0026lt;- data.frame( from = c(1, 2, 3, 1), to = c(2, 3, 1, 4), length = 1, directed = TRUE, stringsAsFactors = F ) gr \u0026lt;- igraph::graph_from_data_frame(net) simplify_igraph_network(gr)#\u0026gt; IGRAPH 34e450f DNW- 2 2 -- #\u0026gt; + attr: name (v/c), length (e/n), directed (e/l), weight (e/n) #\u0026gt; + edges from 34e450f (vertex names): #\u0026gt; [1] 1-\u0026gt;4 1-\u0026gt;1net \u0026lt;- data.frame( from = c(1, 2, 3, 4), to = c(2, 3, 1, 5), length = 1, directed = TRUE, stringsAsFactors = F ) gr \u0026lt;- igraph::graph_from_data_frame(net) simplify_igraph_network(gr)#\u0026gt; IGRAPH e47dc84 DNW- 3 2 -- #\u0026gt; + attr: name (v/c), length (e/n), directed (e/l), weight (e/n) #\u0026gt; + edges from e47dc84 (vertex names): #\u0026gt; [1] 1-\u0026gt;1 4-\u0026gt;5  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_sincell/",
	"title": "Sincell",
	"tags": [],
	"description": "",
	"content": " ti_sincell.Rd  Will generate a trajectory using Sincell.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_sincell(distance_method = \"euclidean\", dimred_method = \"none\", clust.method = \"max.distance\", mutual = TRUE, max.distance = 0L, k = 3L, shortest.rank.percent = 10L, graph.algorithm = \"MST\", graph.using.cells.clustering = FALSE, k_imc = 3L, pct_leaf_node_cutoff = 0.5) Arguments   distance_method Distance method to be used. The available distances are the Euclidean distance (method=\"euclidean\"), Manhattan distance (also called L1 distance, method=\"L1\"), cosine distance (method=\"cosine\") , distance based on Pearson (method=\"pearson\") or Spearman (method=\"spearman\") correlation coefficients, and distance based on Mutual Information (method=\"MI\"). Intervals used to assess Mutual Information are indicated in the parameter 'bins'. Domain: euclidean, cosine, pearson, spearman, L1, MI. Default: euclidean. Format: character.\n   dimred_method Dimensionality reduction algorithm to be used. Options are: Principal Component Analysis (method=\"PCA\"), Independent Component Analysis (method=\"ICA\"; using fastICA() function in fastICA package), t-Distributed Stochastic Neighbor Embedding (method=\"tSNE\"; using Rtsne() function in Rtsne package with parameters tsne.perplexity=1 and tsne.theta=0.25), classical Multidimensional Scaling (method=\"classical-MDS\"; using the cmdscale() function) and non-metric Multidimensional Scaling (method=\"nonmetric-MDS\";using the isoMDS() function in MASS package). if method=\"PCA\" is chosen, the proportion of variance explained by each of the principal axes is plotted. We note that Sincell makes use of the Rtsne implementation of the Barnes-Hut algorithm, which approximates the likelihood. The user should be aware that this is a less accurate version of t-SNE than e.g. the one used as basis of viSNE (Amir,E.D. et al. 2013, Nat Biotechnol 31, 545-552). Domain: none, PCA, ICA, tSNE, classical-MDS, nonmetric-MDS. Default: none. Format: character.\n   clust.method If clust.method=\"max.distance\", clusters are defined as subgraphs generated by a maximum pair-wise distance cut-off, that is: from a totally connected graph where all cells are connected to each other, the algorithm only keeps pairs of cells connected by a distance lower than a given threshold.If clust.method=\"percent\", clusters are defined as subgraphs generated by a given rank-percentile of the shortest pair-wise distances, that is; from a totally connected graph where all cells are connected to each other, the algorithm only keeps the top 'x' percent of shortest pairwise distances as indicated by \"shortest.rank.percent\".If clust.method=\"knn\", unsupervised K-Nearest Neighbors (K-NN) clustering is performed: From a totally disconnected graph where none of the cells are connected to each other, the algorithm connects each cell to its 'k' nearest neighbors. If parameter \"mutual=TRUE\", Unsupervised K-Mutual Nearest Neighbours (K-MNN) clustering is performed, that is: only reciprocal k nearest neighbors are connected.If clust.method=\"k-medoids\", clustering around medoids (a more robust version of k-means) is performed with function \"pam\" from package \"cluster\" on the distance matrix in mySincellObject$cell2celldist with a desired number of groups indicated in parameter \"num.clusters\"Hierarchical agglomerative clustering can be performed by internally calling function \"hclust\" where the agglomeration method is indicated in parameter \"clust.method\" as one of \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" (= UPGMA), \"mcquitty\" (= WPGMA), \"median\" (= WPGMC) or \"centroid\" (= UPGMC). Clusters are obtained by cutting the tree produced by hclust with function cutree with a desired number of groups indicated in parameter \"num.clusters\". Domain: max.distance, percent, knn, k-medoids, ward.D, ward.D2, single, complete, average, mcquitty, median, centroid. Default: max.distance. Format: character.\n   mutual If clust.method=\"knn\" and \"mutual=TRUE\", Unsupervised K-Mutual Nearest Neighbours (K-MNN) clustering is performed, that is only reciprocal k nearest neighbors are connected. Default: TRUE. Format: logical.\n   max.distance In max.distance algorithm, select up to which distance the points will be linked. Domain: U(0, 5). Default: 0. Format: numeric.\n   k If clust.method=\"knn\", k is an integer specifying the number of nearest neighbors to consider in K-NN and K-KNN. Domain: U(1, 99). Default: 3. Format: integer.\n   shortest.rank.percent In percent algorithm, select the percent of shortest distances will be represented as links. Domain: U(0, 100). Default: 10. Format: numeric.\n   graph.algorithm Graph building algorithm to be used; the Minimum Spanning Tree (graph.algorithm=\"MST\"), the Maximum Similarity Spanning Tree (graph.algorithm=\"SST\") and the Iterative Mutual Clustering Graph (graph.algorithm=\"IMC\"). Domain: MST, SST, IMC. Default: MST. Format: character.\n   graph.using.cells.clustering If graph.using.cells.clustering=TRUE and graph.algorithm=\"MST\" or graph.algorithm=\"MST\", a precalculated clustering of cells is used. The clustering of cells is taken from SincellObject$cellsClustering as calculated by function sc_clusterObj(). Default: FALSE. Format: logical.\n   k_imc If IMC algorithm is selected, the number of nearest neighbors used in the underlying K-Mutual Nearest Neighbour (K-MNN) algorithm is set to k. Domain: U(1, 99). Default: 3. Format: integer.\n   pct_leaf_node_cutoff Leaf nodes are iteratively removed until the percentage of leaf nodes is below the given cutoff. Removed nodes are projected to their closest neighbour. This is to constrain the number of milestones being created. Domain: U(0.01, 0.8). Default: 0.5. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Juliá, M., Telenti, A., Rausell, A., 2015. Sincell: an R/Bioconductor package for statistical assessment of cell-state hierarchies from single-cell RNA-seq: Fig. 1. Bioinformatics 31, 3380–3382.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_slingshot/",
	"title": "Slingshot",
	"tags": [],
	"description": "",
	"content": " ti_slingshot.Rd  Will generate a trajectory using Slingshot.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_slingshot(shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \"smooth.spline\", shrink.method = \"cosine\") Arguments   shrink Logical or numeric between 0 and 1, determines whether and how much to shrink branching lineages toward their average prior to the split. Domain: e^U(-Inf, 0.00). Default: 1. Format: numeric.\n   reweight Logical, whether to allow cells shared between lineages to be reweighted during curve-fitting. If TRUE, cells shared between lineages will be weighted by: distance to nearest curve / distance to curve. Default: TRUE. Format: logical.\n   reassign Logical, whether to reassign cells to lineages at each iteration. If TRUE, cells will be added to a lineage when their projection distance to the curve is less than the median distance for all cells currently assigned to the lineage. Additionally, shared cells will be removed from a lineage if their projection distance to the curve is above the 90th percentile and their weight along the curve is less than 0.1. Default: TRUE. Format: logical.\n   thresh Numeric, determines the convergence criterion. Percent change in the total distance from cells to their projections along curves must be less than thresh. Default is 0.001, similar to principal.curve. Domain: e^U(-11.51, 11.51). Default: 0.001. Format: numeric.\n   maxit Numeric, maximum number of iterations, see principal.curve. Domain: U(0, 50). Default: 10. Format: integer.\n   stretch Numeric factor by which curves can be extrapolated beyond endpoints. Default is 2, see principal.curve. Domain: e^U(-Inf, 1.61). Default: 2. Format: numeric.\n   smoother Choice of scatter plot smoother. Same as principal.curve, but \"lowess\" option is replaced with \"loess\" for additional flexibility. Domain: smooth.spline, loess, periodic.lowess. Default: smooth.spline. Format: character.\n   shrink.method Character denoting how to determine the appropriate amount of shrinkage for a branching lineage. Accepted values are the same as for kernel in density() (default is \"cosine\"), as well as \"tricube\" and \"density\". See 'Details' for more. Domain: cosine, tricube, density. Default: cosine. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Street, K., Risso, D., Fletcher, R.B., Das, D., Ngai, J., Yosef, N., Purdom, E., Dudoit, S., 2018. Slingshot: cell lineage and pseudotime inference for single-cell transcriptomics. BMC Genomics 19.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_tscan/",
	"title": "TSCAN",
	"tags": [],
	"description": "",
	"content": " ti_tscan.Rd  Will generate a trajectory using TSCAN.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_tscan(minexpr_percent = 0L, minexpr_value = 0L, cvcutoff = 0L, clusternum = c(2L, 9L), modelNames = \"VVV\") Arguments   minexpr_percent . Domain: U(0, 1). Default: 0. Format: numeric.\n   minexpr_value . Domain: U(0, 10). Default: 0. Format: numeric.\n   cvcutoff . Domain: U(0, 5). Default: 0. Format: numeric.\n   clusternum . Domain: ( U(2, 20), U(2, 20) ). Default: (2, 9). Format: integer_range.\n   modelNames . Domain: EII, VII, EEI, VEI, EVI, VVI, EEE, EVE, VEE, VVE, EEV, VEV, EVV, VVV. Default: VVV. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Ji, Z., Ji, H., 2016. TSCAN: Pseudo-time reconstruction and evaluation in single-cell RNA-seq analysis. Nucleic Acids Research 44, e117–e117.\n Contents Arguments Value References  -- "
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/reference/dynwrap/other/dynwrap/",
	"title": "This R package contains the code for a common model of single-cell trajectories.",
	"tags": [],
	"description": "",
	"content": " Source: R/package.R dynwrap.Rd  This R package contains the code for a common model of single-cell trajectories.\n  Contents  -- "
},
{
	"uri": "/reference/dynwrap/other/wrap_output_list/",
	"title": "Transform a list of data objects to a dynwrap trajectory",
	"tags": [],
	"description": "",
	"content": " Source: R/wrap_output_list.R wrap_output_list.Rd  Transform a list of data objects to a dynwrap trajectory\n wrap_output_list(output, output_ids) Arguments   output A list containing dynwrap data\n   output_ids The names of the promised dynwrap objects\n    Contents Arguments  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_urd/",
	"title": "URD",
	"tags": [],
	"description": "",
	"content": " ti_urd.Rd  Will generate a trajectory using URD.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_urd(knn = 0L, sigma.use = 0, distance = \"euclidean\", n_floods = 20L, stability.div = 10L, mp.factor = 1L, perplexity = 30L, theta = 0.5, max_iter = 1000L, num.nn = 30L, do.jaccard = TRUE, optimal.cells.forward = 20L, max.cells.back = 40L, n.per.tip = 25000L, root.visits = 1L, max.steps = 25000L, n.subsample = 10L, divergence.method = \"ks\", cells.per.pseudotime.bin = 80L, bins.per.pseudotime.window = 5L, p.thresh = 0.01) Arguments   knn Number of nearest neighbors to use. 0 takes a guess. Domain: U(0, 50). Default: 0. Format: integer.\n   sigma.use Kernel width to use for the diffusion map. 0 uses destiny's global auto-detection procedure. Domain: U(0, 1). Default: 0. Format: numeric.\n   distance Distance metric to use for determining transition probabilities. Domain: euclidean, cosine, rankcor. Default: euclidean. Format: character.\n   n_floods Number of simulations to perform and average. Domain: U(5, 50). Default: 20. Format: integer.\n   stability.div Number of simulation subsamplings to calculate. Domain: U(2, 50). Default: 10. Format: numeric.\n   mp.factor Retain PCs than are this factor more than the estimated maximum singular value expected or random data. This is useful in cases when there are many PCs that have standard deviations just above that expected by random, which probably represent noise and should be excluded. Domain: U(0, 10). Default: 1. Format: numeric.\n   perplexity Perplexity parameter for the tSNE. Domain: U(0, 100). Default: 30. Format: numeric.\n   theta Speed/accuracy trade-off for Barnes-Hut approximation of tSNE. 0 is exact tSNE, higher is less accurate. Domain: U(0, 1). Default: 0.5. Format: numeric.\n   max_iter Number of nearest neighbors to use. 0 takes a guess. Domain: e^U(4.61, 9.21). Default: 1000. Format: integer.\n   num.nn How many nearest-neighbors to use in the k-nn graph. Domain: e^U(2.30, 4.61). Default: 30. Format: integer.\n   do.jaccard Weight edges in the k-nn graph according to their Jaccard overlap?. Default: TRUE. Format: logical.\n   optimal.cells.forward The number of cells in the direction specified by pseudotime.direction at which the logistic should reach 1-asymptote. Domain: e^U(1.61, 4.61). Default: 20. Format: numeric.\n   max.cells.back The number of cells in the direction opposite from that specified by pseudotime.direction at which the logistic should reach asymptote. Domain: e^U(1.61, 5.30). Default: 40. Format: numeric.\n   n.per.tip Number of walks to do per tip. Domain: e^U(4.61, 13.82). Default: 25000. Format: integer.\n   root.visits Number of steps to take that visit a root.cell before stopping. Domain: U(1, 5). Default: 1. Format: integer.\n   max.steps Number of walks to do per tip. Domain: e^U(4.61, 13.82). Default: 25000. Format: integer.\n   n.subsample Number of subsamplings to perform for calculating stability. Domain: e^U(0.69, 4.61). Default: 10. Format: integer.\n   divergence.method Distance metric to use for determining transition probabilities. Domain: ks, preference. Default: ks. Format: character.\n   cells.per.pseudotime.bin Approximate number of cells to assign to each pseudotime bin for branchpoint finding. Domain: e^U(2.30, 6.91). Default: 80. Format: integer.\n   bins.per.pseudotime.window Width of moving window in pseudotime used for branchpoint finding, in terms of bins. Domain: U(2, 20). Default: 5. Format: integer.\n   p.thresh P-value threshold to use in determining whether visitation is significantly different from pairs of tips. Domain: e^U(-11.51, 0.00). Default: 0.01. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Farrell, J.A., Wang, Y., Riesenfeld, S.J., Shekhar, K., Regev, A., Schier, A.F., 2018. Single-cell reconstruction of developmental trajectories during zebrafish embryogenesis. Science 360, eaar3131.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_wanderlust/",
	"title": "Wanderlust",
	"tags": [],
	"description": "",
	"content": " ti_wanderlust.Rd  Will generate a trajectory using Wanderlust.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_wanderlust(normalise = TRUE, knn = 25L, n_diffusion_components = 3L, n_pca_components = 30L, k = 25L, num_waypoints = 250L, epsilon = 1L) Arguments   normalise . Default: TRUE. Format: logical.\n   knn K-nearest neighbours for diffusion. Domain: U(15, 100). Default: 25. Format: integer.\n   n_diffusion_components Number of diffusion components. Domain: U(3, 20). Default: 3. Format: integer.\n   n_pca_components Number of pca components. Domain: U(15, 100). Default: 30. Format: integer.\n   k K parameter. Domain: U(15, 100). Default: 25. Format: integer.\n   num_waypoints Number of waypoints. Domain: U(100, 500). Default: 250. Format: integer.\n   epsilon Epsilon. Domain: U(0.1, 5). Default: 1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Bendall, S.C., Davis, K.L., Amir, E.D., Tadmor, M.D., Simonds, E.F., Chen, T.J., Shenfeld, D.K., Nolan, G.P., Pe’er, D., 2014. Single-Cell Trajectory Detection Uncovers Progression and Regulatory Coordination in Human B Cell Development. Cell 157, 714–725.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_waterfall/",
	"title": "Waterfall",
	"tags": [],
	"description": "",
	"content": " ti_waterfall.Rd  Will generate a trajectory using Waterfall.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_waterfall(num_clusters = 10L) Arguments   num_clusters . Domain: U(2, 20). Default: 10. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Shin, J., Berg, D.A., Zhu, Y., Shin, J.Y., Song, J., Bonaguidi, M.A., Enikolopov, G., Nauen, D.W., Christian, K.M., Ming, G., Song, H., 2015. Single-Cell RNA-Seq with Waterfall Reveals Molecular Cascades underlying Adult Neurogenesis. Cell Stem Cell 17, 360–372.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynplot/plot_helpers/theme_clean/",
	"title": "We like our plots clean",
	"tags": [],
	"description": "",
	"content": " theme_clean.Rd  We like our plots clean\n theme_clean()  Contents  -- "
},
{
	"uri": "/reference/dynplot/plot_helpers/theme_graph/",
	"title": "We like our plots clean",
	"tags": [],
	"description": "",
	"content": " theme_graph.Rd  We like our plots clean\n theme_graph()  Contents  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_wishbone/",
	"title": "Wishbone",
	"tags": [],
	"description": "",
	"content": " ti_wishbone.Rd  Will generate a trajectory using Wishbone.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_wishbone(normalise = TRUE, knn = 25L, n_diffusion_components = 3L, n_pca_components = 30L, k = 25L, num_waypoints = 250L, epsilon = 1L) Arguments   normalise . Default: TRUE. Format: logical.\n   knn K-nearest neighbours for diffusion. Domain: U(15, 100). Default: 25. Format: integer.\n   n_diffusion_components Number of diffusion components. Domain: U(3, 20). Default: 3. Format: integer.\n   n_pca_components Number of pca components. Domain: U(15, 100). Default: 30. Format: integer.\n   k K parameter. Domain: U(15, 100). Default: 25. Format: integer.\n   num_waypoints Number of waypoints. Domain: U(100, 500). Default: 250. Format: integer.\n   epsilon Epsilon. Domain: U(0.1, 5). Default: 1. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Setty, M., Tadmor, M.D., Reich-Zeliger, S., Angel, O., Salame, T.M., Kathail, P., Choi, K., Bendall, S., Friedman, N., Pe’er, D., 2016. Wishbone identifies bifurcating developmental trajectories from single-cell data. Nature Biotechnology 34, 637–645.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/dynmethods/",
	"title": "Wrappers for trajectory inference methods",
	"tags": [],
	"description": "",
	"content": " dynmethods.Rd  Wrappers for trajectory inference methods\n  Contents  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_celltree_gibbs/",
	"title": "cellTree Gibbs",
	"tags": [],
	"description": "",
	"content": " ti_celltree_gibbs.Rd  Will generate a trajectory using cellTree Gibbs.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_celltree_gibbs(method = \"Gibbs\", sd_filter = 0.5, width_scale_factor = 1.5, outlier_tolerance_factor = 0.1, rooting_method = \"null\", num_topics = 4L, tot_iter = 200L, tolerance = 1e-05) Arguments   method LDA inference method to use. Domain: Gibbs. Default: Gibbs. Format: character.\n   sd_filter Standard-deviation threshold below which genes should be removed from the data. Domain: e^U(-4.61, 1.61). Default: 0.5. Format: numeric.\n   width_scale_factor A scaling factor for the dynamically-computed distance threshold (ignored if absolute_width is provided). Higher values will result in less branches in the backbone tree, while lower values might lead to a large number of backbone branches. Domain: e^U(-2.30, 4.61). Default: 1.5. Format: numeric.\n   outlier_tolerance_factor Proportion of vertices, out of the total number of vertices divided by the total number of branches, that can be left at the end of the backbone tree-building algorithm. Domain: e^U(-9.21, 6.91). Default: 0.1. Format: numeric.\n   rooting_method Method used to root the backbone tree. Must be either NULL or one of ‘longest.path’, ‘center.start.group’ or ‘average.start.group’. ‘longest.path’ picks one end of the longest shortest-path between two vertices. ’center.start.group’ picks the vertex in the starting group with lowest mean-square-distance to the others. ‘average.start.group’ creates a new artificial vertex, as the average of all cells in the starting group. If no value is provided, the best method is picked based on the type of grouping and start group information available. Domain: longest.path, center.start.group, average.start.group, null. Default: null. Format: character.\n   num_topics Number of topics to fit in the model. Domain: U(2, 15). Default: 4. Format: integer.\n   tot_iter Numeric parameters (optional) forwarded to the chosen LDA inference method's contol class. Domain: e^U(2.30, 6.91). Default: 200. Format: numeric.\n   tolerance Numeric parameters (optional) forwarded to the chosen LDA inference method's contol class. Domain: e^U(-16.12, -6.91). Default: 1e-05. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences duVerle, D.A., Yotsukura, S., Nomura, S., Aburatani, H., Tsuda, K., 2016. CellTree: an R/bioconductor package to infer the hierarchical structure of cell populations from single-cell RNA-seq data. BMC Bioinformatics 17.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_celltree_maptpx/",
	"title": "cellTree maptpx",
	"tags": [],
	"description": "",
	"content": " ti_celltree_maptpx.Rd  Will generate a trajectory using cellTree maptpx.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_celltree_maptpx(method = \"maptpx\", sd_filter = 0.5, absolute_width = 0L, width_scale_factor = 1.5, outlier_tolerance_factor = 0.1, rooting_method = \"null\", num_topics = c(2L, 15L), tot_iter = 200L, tolerance = 0.05) Arguments   method LDA inference method to use. Domain: maptpx. Default: maptpx. Format: character.\n   sd_filter Standard-deviation threshold below which genes should be removed from the data. Domain: e^U(-4.61, 1.61). Default: 0.5. Format: numeric.\n   absolute_width Distance threshold below which a cell vertex is considered to be attached to a backbone vertex (see paper for more details). By default, this threshold is computed dynamically, based on the distance distribution for each branch. Domain: U(0, 1). Default: 0. Format: numeric.\n   width_scale_factor A scaling factor for the dynamically-computed distance threshold (ignored if absolute_width is provided). Higher values will result in less branches in the backbone tree, while lower values might lead to a large number of backbone branches. Domain: e^U(-2.30, 4.61). Default: 1.5. Format: numeric.\n   outlier_tolerance_factor Proportion of vertices, out of the total number of vertices divided by the total number of branches, that can be left at the end of the backbone tree-building algorithm. Domain: e^U(-9.21, 6.91). Default: 0.1. Format: numeric.\n   rooting_method Method used to root the backbone tree. Must be either NULL or one of ‘longest.path’, ‘center.start.group’ or ‘average.start.group’. ‘longest.path’ picks one end of the longest shortest-path between two vertices. ’center.start.group’ picks the vertex in the starting group with lowest mean-square-distance to the others. ‘average.start.group’ creates a new artificial vertex, as the average of all cells in the starting group. If no value is provided, the best method is picked based on the type of grouping and start group information available. Domain: longest.path, center.start.group, average.start.group, null. Default: null. Format: character.\n   num_topics Number of topics to fit in the model. Domain: ( U(2, 10), U(10, 30) ). Default: (2, 15). Format: integer_range.\n   tot_iter Numeric parameters (optional) forwarded to the chosen LDA inference method's contol class. Domain: e^U(9.21, 13.82). Default: 200. Format: numeric.\n   tolerance Numeric parameters (optional) forwarded to the chosen LDA inference method's contol class. Domain: e^U(-6.91, -0.69). Default: 0.05. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences duVerle, D.A., Yotsukura, S., Nomura, S., Aburatani, H., Tsuda, K., 2016. CellTree: an R/bioconductor package to infer the hierarchical structure of cell populations from single-cell RNA-seq data. BMC Bioinformatics 17.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_celltree_vem/",
	"title": "cellTree vem",
	"tags": [],
	"description": "",
	"content": " ti_celltree_vem.Rd  Will generate a trajectory using cellTree vem.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_celltree_vem(method = \"VEM\", sd_filter = 0.5, width_scale_factor = 1.5, outlier_tolerance_factor = 0.1, rooting_method = \"null\", num_topics = 4L, tot_iter = 1000000L, tolerance = 1e-05) Arguments   method LDA inference method to use. Domain: VEM. Default: VEM. Format: character.\n   sd_filter Standard-deviation threshold below which genes should be removed from the data. Domain: e^U(-4.61, 1.61). Default: 0.5. Format: numeric.\n   width_scale_factor A scaling factor for the dynamically-computed distance threshold (ignored if absolute_width is provided). Higher values will result in less branches in the backbone tree, while lower values might lead to a large number of backbone branches. Domain: e^U(-2.30, 4.61). Default: 1.5. Format: numeric.\n   outlier_tolerance_factor Proportion of vertices, out of the total number of vertices divided by the total number of branches, that can be left at the end of the backbone tree-building algorithm. Domain: e^U(-9.21, 6.91). Default: 0.1. Format: numeric.\n   rooting_method Method used to root the backbone tree. Must be either NULL or one of ‘longest.path’, ‘center.start.group’ or ‘average.start.group’. ‘longest.path’ picks one end of the longest shortest-path between two vertices. ’center.start.group’ picks the vertex in the starting group with lowest mean-square-distance to the others. ‘average.start.group’ creates a new artificial vertex, as the average of all cells in the starting group. If no value is provided, the best method is picked based on the type of grouping and start group information available. Domain: longest.path, center.start.group, average.start.group, null. Default: null. Format: character.\n   num_topics Number of topics to fit in the model. Domain: U(2, 15). Default: 4. Format: integer.\n   tot_iter Numeric parameters (optional) forwarded to the chosen LDA inference method's contol class. Domain: e^U(9.21, 16.12). Default: 1000000. Format: numeric.\n   tolerance Numeric parameters (optional) forwarded to the chosen LDA inference method's contol class. Domain: e^U(-16.12, -6.91). Default: 1e-05. Format: numeric.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences duVerle, D.A., Yotsukura, S., Nomura, S., Aburatani, H., Tsuda, K., 2016. CellTree: an R/bioconductor package to infer the hierarchical structure of cell populations from single-cell RNA-seq data. BMC Bioinformatics 17.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dyneval/metric/calculate_him/",
	"title": "netdist scores",
	"tags": [],
	"description": "",
	"content": " calculate_him.Rd  netdist scores\n calculate_him(net1, net2, simplify = TRUE) Arguments   net1 Network 1\n   net2 Network 2\n   simplify Whether or not to simplify the networks\n   Examples net1 \u0026lt;- dyntoy::generate_milestone_network(\"linear\") net2 \u0026lt;- dyntoy::generate_milestone_network(\"bifurcating\") calculate_him(net1, net2)#\u0026gt; Error in calculate_him(net1, net2): could not find function \"calculate_him\"net1 \u0026lt;- dyntoy::generate_milestone_network(\"cyclic\") net2 \u0026lt;- dyntoy::generate_milestone_network(\"cyclic\") calculate_him(net1, net2)#\u0026gt; Error in calculate_him(net1, net2): could not find function \"calculate_him\"  Contents Arguments Examples  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_ouija/",
	"title": "ouija",
	"tags": [],
	"description": "",
	"content": " ti_ouija.Rd  Will generate a trajectory using ouija.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_ouija(iter = 100L, response_type = \"switch\", inference_type = \"hmc\", normalise_expression = TRUE) Arguments   iter Number of iterations. Domain: e^U(2.30, 6.91). Default: 100. Format: numeric.\n   response_type A vector declaring whether each gene exhibits \"switch\" or \"transient\"expression. Defaults to \"switch\" for all genes. Domain: switch, transient. Default: switch. Format: character.\n   inference_type The type of inference to be performed, either hmc for HamiltonianMonte Carlo or vb for ADVI (Variational Bayes). Note that HMC is typically more accuratebut VB will be orders of magnitude faster. Domain: hmc, vb. Default: hmc. Format: character.\n   normalise_expression Logical, default TRUE. If TRUE the data is pre-normalisedso the average peak expression is approximately 1. This makes the strength parametersapproximately comparable between genes. Default: TRUE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Campbell, K.R., Yau, C., 2016. A descriptive marker gene approach to single-cell pseudotime inference.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_ouijaflow/",
	"title": "ouijaflow",
	"tags": [],
	"description": "",
	"content": " ti_ouijaflow.Rd  Will generate a trajectory using ouijaflow.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_ouijaflow(iter = 1000L) Arguments   iter . Domain: e^U(0.69, 10.82). Default: 1000. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Campbell, K.R., Yau, C., 2016. A descriptive marker gene approach to single-cell pseudotime inference.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_pcreode/",
	"title": "pCreode",
	"tags": [],
	"description": "",
	"content": " ti_pcreode.Rd  Will generate a trajectory using pCreode.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_pcreode(n_pca_components = 3L, num_runs = 10L) Arguments   n_pca_components . Domain: U(2, 10). Default: 3. Format: integer.\n   num_runs . Domain: e^U(2.30, 4.61). Default: 10. Format: integer.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Herring, C.A., Banerjee, A., McKinley, E.T., Simmons, A.J., Ping, J., Roland, J.T., Franklin, J.L., Liu, Q., Gerdes, M.J., Coffey, R.J., Lau, K.S., 2018. Unsupervised Trajectory Analysis of Single-Cell RNA-Seq and Imaging Data Reveals Alternative Tuft Cell Origins in the Gut. Cell Systems 6, 37–51.e9.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_pseudogp/",
	"title": "pseudogp",
	"tags": [],
	"description": "",
	"content": " ti_pseudogp.Rd  Will generate a trajectory using pseudogp.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_pseudogp(smoothing_alpha = 10, smoothing_beta = 3, pseudotime_mean = 0.5, pseudotime_var = 1, chains = 3L, iter = 100L, dimreds = c(\"pca\", \"mds\"), initialise_from = \"random\") Arguments   smoothing_alpha The hyperparameter for the Gamma distribution that controls arc-length. Domain: U(1, 20). Default: 10. Format: numeric.\n   smoothing_beta The hyperparameter for the Gamma distribution that controls arc-length. Domain: U(1, 20). Default: 3. Format: numeric.\n   pseudotime_mean The mean of the constrained normal prior on the pseudotimes. Domain: U(0, 1). Default: 0.5. Format: numeric.\n   pseudotime_var The variance of the constrained normal prior on the pseudotimes. Domain: U(0.01, 1). Default: 1. Format: numeric.\n   chains The number of chains for the MCMC trace. Domain: U(1, 20). Default: 3. Format: integer.\n   iter The number of iterations for the MCMC trace. Domain: e^U(4.61, 6.91). Default: 100. Format: integer.\n   dimreds A character vector specifying which dimensionality reduction methods to use. See dyndimred::dimred() for the list of available dimensionality reduction methods. Domain: all subsets of pca, mds, tsne, ica, lle, landmark_mds, mds_sammon, mds_isomds, mds_smacof, umap, dm_diffusionmap, dm_destiny. Default: pca, mds. Format: subset.\n   initialise_from How to initialise the MCMC chain. One of \"random\" (stan decides),\"principal_curve\", or \"pca\" (the first component of PCA rescaled is taken to be the pseudotimes).Note: if multiple representations are provided, pseudogp will take the principal curve orpca from the first rather than combining them. If a particular representation is required, it isup to the user to re-order them. Domain: random, principal_curve, pca. Default: random. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Campbell, K.R., Yau, C., 2016. Order Under Uncertainty: Robust Differential Expression Analysis Using Probabilistic Models for Pseudotime Inference. PLOS Computational Biology 12, e1005212.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_recat/",
	"title": "reCAT",
	"tags": [],
	"description": "",
	"content": " ti_recat.Rd  Will generate a trajectory using reCAT.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_recat(TSPFold = 2L, beginNum = 10L, endNum = 15L, step_size = 2L, base_cycle_range = c(6L, 9L), max_num = 300L, clustMethod = \"GMM\") Arguments   TSPFold No documentation provided by authors. Domain: U(2, 10). Default: 2. Format: integer.\n   beginNum No documentation provided by authors. Domain: U(2, 20). Default: 10. Format: integer.\n   endNum No documentation provided by authors. Domain: U(2, 20). Default: 15. Format: integer.\n   step_size Determines the number of k to skip in your consensus path, ie ifstep_size = 2, then reCAT would only calculate and merge the paths fork = 12, 14, 16, 18, ..., n-2, n. We recommend step_size of up to a maximum of 5 while preserving the performance of reCAT. Usually a step_size of 2 (by default) would suffice and bigger steps are recommended for larger datasets (\u0026gt;1000 cells) in order to reduce computational time. Domain: U(2, 20). Default: 2. Format: integer.\n   base_cycle_range . Domain: ( U(5, 10), U(5, 10) ). Default: (6, 9). Format: integer_range.\n   max_num No documentation provided by authors. Domain: U(100, 500). Default: 300. Format: integer.\n   clustMethod No documentation provided by authors. Domain: GMM, Pam, Kmeans. Default: GMM. Format: character.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Liu, Z., Lou, H., Xie, K., Wang, H., Chen, N., Aparicio, O.M., Zhang, M.Q., Jiang, R., Chen, T., 2017. Reconstructing cell cycle pseudo time-series via single-cell transcriptome data. Nature Communications 8.\n Contents Arguments Value References  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_shuffle/",
	"title": "shuffle",
	"tags": [],
	"description": "",
	"content": " ti_shuffle.Rd  Will generate a trajectory using shuffle.\nThis method was wrapped inside a container.\n ti_shuffle(dummy_param = TRUE) Arguments   dummy_param Dummy parameter. Default: TRUE. Format: logical.\n   Value A TI method wrapper to be used together with infer_trajectory\n Contents Arguments Value  -- "
},
{
	"uri": "/reference/dynmethods/other/ti_topslam/",
	"title": "topslam",
	"tags": [],
	"description": "",
	"content": " ti_topslam.Rd  Will generate a trajectory using topslam.\nThis method was wrapped inside a container. The original code of this method is available here.\n ti_topslam(n_components = 2L, n_neighbors = 10L, linear_dims = 0L, max_iters = 1000L, dimreds = c(\"t-SNE\", \"PCA\", \"Spectral\", \"Isomap\", \"ICA\")) Arguments   n_components The number of components. Domain: U(2, 10). Default: 2. Format: integer.\n   n_neighbors The number of neighbors. Domain: U(2, 100). Default: 10. Format: integer.\n   linear_dims . Domain: U(0, 5). Default: 0. Format: integer.\n   max_iters The number of iterations to optimize over. Domain: e^U(2.30, 9.21). Default: 1000. Format: integer.\n   dimreds Which dimensionality reductions to use and/or ICA. Domain: all subsets of t-SNE, PCA, Spectral, Isomap, ICA. Default: t-SNE, PCA, Spectral, Isomap, ICA. Format: subset.\n   Value A TI method wrapper to be used together with infer_trajectory\nReferences Zwiessele, M., Lawrence, N.D., 2016. Topslam: Waddington Landscape Recovery for Single Cell Experiments.\n Contents Arguments Value References  -- "
}]